<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Build Lab">
<title>Build Lab â€” Engineering Adventure</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html, body { width:100%; height:100%; overflow:hidden; font-family:'Segoe UI',system-ui,-apple-system,sans-serif; background:#0a0e27; }
  body { display:flex; justify-content:center; align-items:center; }
  #app { width:100%; max-width:960px; height:100dvh; height:100vh; position:relative; overflow:hidden; }
  @supports (height: 100dvh) { #app { height:100dvh; } }

  .screen { position:absolute; inset:0; display:none; flex-direction:column; overflow-y:auto; -webkit-overflow-scrolling:touch; }
  .screen.active { display:flex; animation:screenIn .35s ease-out; }
  @keyframes screenIn { from{opacity:0;transform:translateY(12px)} to{opacity:1;transform:translateY(0)} }
  .btn {
    border:none; border-radius:16px; font-weight:700; cursor:pointer; letter-spacing:.5px;
    transition:transform .15s,box-shadow .15s,filter .15s; font-family:inherit; text-align:center;
    position:relative; overflow:hidden;
  }
  .btn::after {
    content:''; position:absolute; inset:0; background:linear-gradient(180deg,rgba(255,255,255,.15) 0%,transparent 60%);
    pointer-events:none; border-radius:inherit;
  }
  .btn:active { transform:scale(.94); filter:brightness(1.1); }
  .btn-lg { padding:18px 50px; font-size:22px; border-radius:25px; }
  .btn-md { padding:12px 28px; font-size:17px; }
  .btn-sm { padding:8px 16px; font-size:13px; border-radius:11px; }
  .btn-orange { background:linear-gradient(135deg,#FF9800,#F57C00); color:#fff; box-shadow:0 4px 18px #FF980055,0 0 30px #FF980022; }
  .btn-blue { background:linear-gradient(135deg,#42A5F5,#1565C0); color:#fff; box-shadow:0 4px 18px #2196F355,0 0 30px #2196F322; }
  .btn-green { background:linear-gradient(135deg,#66BB6A,#2E7D32); color:#fff; box-shadow:0 4px 18px #4CAF5055,0 0 30px #4CAF5022; }
  .btn-red { background:linear-gradient(135deg,#EF5350,#C62828); color:#fff; box-shadow:0 4px 18px #F4433655,0 0 30px #F4433622; }
  .btn-gray { background:linear-gradient(135deg,#90A4AE,#546E7A); color:#fff; box-shadow:0 4px 12px #78909C33; }
  .btn-purple { background:linear-gradient(135deg,#B388FF,#651FFF); color:#fff; box-shadow:0 4px 18px #7C4DFF55,0 0 30px #7C4DFF22; }
  .btn-teal { background:linear-gradient(135deg,#26A69A,#00695C); color:#fff; box-shadow:0 4px 18px #00968855,0 0 30px #00968822; }
  .btn-pink { background:linear-gradient(135deg,#F06292,#AD1457); color:#fff; box-shadow:0 4px 18px #E91E6355,0 0 30px #E91E6322; }
  .btn-amber { background:linear-gradient(135deg,#FFB300,#E65100); color:#fff; box-shadow:0 4px 18px #FF8F0055,0 0 30px #FF8F0022; }
  .btn-cyan { background:linear-gradient(135deg,#00BCD4,#006064); color:#fff; box-shadow:0 4px 18px #00BCD455,0 0 30px #00BCD422; }
  .stars { display:flex; gap:4px; }
  .star { font-size:28px; transition:transform .3s; }
  .star.on { color:#FFD700; text-shadow:0 2px 12px rgba(255,215,0,.7),0 0 20px rgba(255,215,0,.3); transform:scale(1.15); }
  .star.off { color:#455A64; transform:scale(.85); }

  #menu {
    background:linear-gradient(135deg,#0a0e27 0%,#1a237e 30%,#283593 60%,#1565C0 100%);
    background-size:300% 300%; animation:menuBG 8s ease infinite;
    align-items:center; justify-content:center; gap:14px; padding:24px 30px; text-align:center;
  }
  @keyframes menuBG { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
  #menu .bg-icons { position:absolute; inset:0; pointer-events:none; overflow:hidden; }
  #menu .bg-icon { position:absolute; opacity:.08; animation:floatIcon 6s ease-in-out infinite; }
  @keyframes floatIcon { 0%,100%{transform:translateY(0) rotate(0deg)} 50%{transform:translateY(-12px) rotate(8deg)} }
  #menu h1 {
    font-size:min(14vw,60px); font-weight:900; color:#fff;
    text-shadow:0 4px 20px rgba(0,0,0,.4),0 0 40px rgba(66,165,245,.4),0 0 80px rgba(66,165,245,.15);
    letter-spacing:4px; z-index:1;
  }
  #menu .subtitle { font-size:20px; color:#90CAF9; font-weight:600; z-index:1; letter-spacing:2px; }
  #menu .star-count { color:#FFD700; font-size:20px; font-weight:700; z-index:1; text-shadow:0 0 12px rgba(255,215,0,.4); }
  #menu .age-note { color:#5C6BC0; font-size:13px; z-index:1; }

  #worlds { background:linear-gradient(160deg,#0d1b2a 0%,#1b2838 40%,#1a3a4a 100%); padding:24px; gap:20px; }
  .worlds-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; max-width:560px; margin:0 auto; width:100%; }
  .world-card {
    padding:22px 16px; border-radius:22px; border:2px solid rgba(255,255,255,.1); text-align:center; cursor:pointer;
    transition:transform .2s,box-shadow .2s; position:relative; font-family:inherit; color:#fff;
    overflow:hidden;
  }
  .world-card::before {
    content:''; position:absolute; inset:0;
    background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.12),transparent 60%);
    pointer-events:none;
  }
  .world-card:active { transform:scale(.95); }
  .world-card .emoji { font-size:48px; margin-bottom:8px; filter:drop-shadow(0 4px 8px rgba(0,0,0,.3)); animation:cardEmoji 3s ease-in-out infinite; }
  @keyframes cardEmoji { 0%,100%{transform:scale(1) rotate(0)} 50%{transform:scale(1.08) rotate(3deg)} }
  .world-card .wname { font-size:20px; font-weight:800; margin-bottom:4px; text-shadow:0 2px 8px rgba(0,0,0,.3); }
  .world-card .wdesc { font-size:12px; opacity:.8; margin-bottom:8px; }
  .world-card .wstars { font-size:13px; opacity:.9; text-shadow:0 0 8px rgba(255,215,0,.3); }

  #levels { background:linear-gradient(160deg,#0d1b2a 0%,#1b2838 40%,#1a3a4a 100%); padding:24px; gap:14px; }
  .level-btn {
    display:flex; align-items:center; gap:14px; padding:14px 18px; border-radius:16px;
    border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.06); backdrop-filter:blur(8px);
    cursor:pointer; text-align:left; font-family:inherit;
    box-shadow:0 4px 16px rgba(0,0,0,.2); transition:transform .2s,box-shadow .2s; width:100%;
  }
  .level-btn:active { transform:scale(.97); box-shadow:0 2px 8px rgba(0,0,0,.3); }
  .level-btn.locked { opacity:.4; cursor:default; }
  .level-num {
    width:46px; height:46px; border-radius:13px; display:flex; align-items:center; justify-content:center;
    font-size:20px; font-weight:900; color:#fff; flex-shrink:0;
  }
  .level-info { flex:1; }
  .level-name { font-size:16px; font-weight:700; color:#E0E0E0; }
  .level-sub { font-size:12px; color:#90A4AE; }

  #intro { background:linear-gradient(160deg,#0a0e27 0%,#1a237e 50%,#0d47a1 100%); align-items:center; justify-content:center; padding:24px; gap:14px; text-align:center; }
  .intro-emoji { font-size:56px; animation:introEmoji 2s ease-in-out infinite; filter:drop-shadow(0 4px 12px rgba(0,0,0,.4)); }
  @keyframes introEmoji { 0%,100%{transform:scale(1) rotate(-3deg)} 50%{transform:scale(1.1) rotate(3deg)} }
  .intro-title { font-size:min(8vw,30px); font-weight:800; color:#fff; text-shadow:0 2px 12px rgba(0,0,0,.3); }
  .intro-desc { font-size:15px; color:#B0BEC5; max-width:440px; line-height:1.5; }
  .tip-card, .fact-card { border-radius:16px; padding:14px 20px; max-width:440px; width:100%; text-align:left; backdrop-filter:blur(8px); }
  .tip-card { background:rgba(255,152,0,.12); border:1px solid rgba(255,152,0,.3); }
  .tip-card .label { font-size:13px; font-weight:700; color:#FFB74D; margin-bottom:5px; }
  .tip-card .body { font-size:14px; color:#FFE0B2; line-height:1.5; }
  .fact-card { background:rgba(33,150,243,.1); border:1px solid rgba(33,150,243,.25); }
  .fact-card .label { font-size:13px; font-weight:700; color:#64B5F6; margin-bottom:5px; }
  .fact-card .body { font-size:14px; color:#BBDEFB; line-height:1.5; }

  #game { background:linear-gradient(160deg,#0d1b2a,#172a3a); padding:6px 8px; gap:4px; padding-bottom:max(6px, env(safe-area-inset-bottom)); }
  .game-topbar {
    display:flex; align-items:center; justify-content:space-between; padding:6px 10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1); border-radius:12px;
    backdrop-filter:blur(8px); flex-shrink:0;
  }
  .game-topbar .title { font-size:14px; font-weight:800; color:#E0E0E0; }
  .game-topbar .meta { font-size:10px; color:#90A4AE; }
  .canvas-wrap {
    display:flex; justify-content:center; border-radius:14px; overflow:hidden;
    box-shadow:0 4px 24px rgba(0,0,0,.3),0 0 40px rgba(33,150,243,.06); flex:1; min-height:0; position:relative;
    border:1px solid rgba(255,255,255,.06);
  }
  .canvas-wrap canvas { width:100%; height:100%; touch-action:none; cursor:pointer; display:block; }
  .game-bottombar {
    display:flex; align-items:center; justify-content:space-between; padding:8px 10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1); border-radius:14px;
    backdrop-filter:blur(8px); flex-shrink:0;
  }
  .mat-btn {
    padding:8px 14px; border-radius:11px; border:2px solid rgba(255,255,255,.15);
    cursor:pointer; display:flex; align-items:center; gap:5px;
    font-size:13px; font-weight:700; color:#E0E0E0; background:rgba(255,255,255,.08); font-family:inherit;
    transition:all .2s;
  }
  .mat-btn.active { border-color:#42A5F5; background:rgba(33,150,243,.2); color:#fff; box-shadow:0 0 12px rgba(33,150,243,.3); }
  .progress-bar { height:8px; border-radius:4px; background:rgba(255,255,255,.1); overflow:hidden; margin-top:6px; }
  .progress-fill { height:100%; border-radius:4px; background:linear-gradient(90deg,#66BB6A,#42A5F5,#7C4DFF); background-size:200%; animation:progressGlow 2s linear infinite; transition:width .1s; }
  @keyframes progressGlow { 0%{background-position:200% 0} 100%{background-position:0% 0} }

  .help-overlay {
    position:absolute; inset:0; background:rgba(0,0,0,.6); display:flex;
    align-items:center; justify-content:center; z-index:20;
  }
  .help-box {
    background:rgba(0,0,0,.88); color:#fff; border-radius:20px; padding:24px 30px;
    max-width:310px; text-align:center; box-shadow:0 8px 30px rgba(0,0,0,.3);
  }
  .help-box .hicon { font-size:36px; margin-bottom:8px; }
  .help-box h3 { font-size:18px; font-weight:700; margin-bottom:10px; }
  .help-box p { font-size:14px; line-height:1.7; margin-bottom:12px; }

  .failure-overlay {
    position:absolute; inset:0; background:rgba(0,0,0,.75); display:none;
    align-items:center; justify-content:center; z-index:25;
  }
  .failure-overlay.active { display:flex; }
  .failure-box {
    background:linear-gradient(135deg,#2d0a0a,#1a0000); color:#fff; border-radius:20px; padding:24px;
    max-width:340px; text-align:center; border:2px solid #F44336; box-shadow:0 8px 40px rgba(244,67,54,.3);
  }
  .failure-box .ficon { font-size:40px; margin-bottom:8px; }
  .failure-box h3 { font-size:19px; font-weight:800; color:#F44336; margin-bottom:10px; }
  .failure-box .cause { font-size:14px; color:#FFCDD2; line-height:1.6; margin-bottom:14px; }
  .hint-card {
    background:rgba(255,152,0,.15); border:1px solid #FF9800; border-radius:12px;
    padding:12px 16px; margin-bottom:16px; text-align:left;
  }
  .hint-card .hlabel { font-size:11px; font-weight:800; color:#FF9800; margin-bottom:4px; letter-spacing:1px; }
  .hint-card .hbody { font-size:13px; color:#FFE0B2; line-height:1.5; }

  .hint-banner {
    display:none; padding:6px 12px; background:rgba(255,152,0,.12); border-radius:10px; text-align:center;
    border:1px solid rgba(255,152,0,.3); flex-shrink:0; backdrop-filter:blur(8px);
  }
  .hint-banner.active { display:block; }
  .hint-banner .hlabel { font-size:11px; font-weight:700; color:#FFB74D; }
  .hint-banner .htext { font-size:12px; color:#FFE0B2; }

  #result { align-items:center; justify-content:center; padding:24px; gap:12px; text-align:center; }
  #result.success { background:linear-gradient(160deg,#0a1a0a 0%,#0d2818 40%,#1a3a2a 100%); }
  #result.fail { background:linear-gradient(160deg,#1a0a0a 0%,#2d1212 40%,#3a1a1a 100%); }
  .result-emoji { font-size:56px; filter:drop-shadow(0 4px 16px rgba(0,0,0,.4)); }
  .result-title { font-size:min(7vw,30px); font-weight:900; text-shadow:0 2px 12px rgba(0,0,0,.3); }
  .result-title.win { color:#66BB6A; text-shadow:0 0 20px rgba(76,175,80,.4); }
  .result-title.lose { color:#EF5350; text-shadow:0 0 20px rgba(244,67,54,.4); }
  .principle-card { background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:16px 22px; max-width:410px; backdrop-filter:blur(8px); }
  .principle-card .label { font-size:13px; font-weight:700; color:#64B5F6; margin-bottom:5px; }
  .principle-card .body { font-size:15px; color:#CFD8DC; line-height:1.5; }
  .result-hint { font-size:15px; color:#90A4AE; max-width:340px; line-height:1.5; }
  .result-btns { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; justify-content:center; }
  .back-link { background:none; border:none; color:#5C6BC0; font-size:14px; cursor:pointer; margin-top:6px; font-family:inherit; }
  #confettiCanvas { position:fixed; inset:0; pointer-events:none; z-index:999; }
  #badges { background:linear-gradient(160deg,#0a0e27 0%,#1a1a3e 40%,#2a1a3a 100%); padding:24px; gap:14px; }
  .badges-grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; max-width:520px; margin:0 auto; width:100%; }
  .badge-card {
    padding:16px 10px; border-radius:16px; text-align:center; background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.08); box-shadow:0 3px 12px rgba(0,0,0,.2); transition:transform .15s;
  }
  .badge-card.earned { background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(255,183,77,.1)); border-color:rgba(255,215,0,.3); box-shadow:0 4px 16px rgba(255,215,0,.2),0 0 20px rgba(255,215,0,.08); }
  .badge-card.locked { opacity:.35; }
  .badge-emoji { font-size:36px; margin-bottom:4px; filter:drop-shadow(0 2px 6px rgba(0,0,0,.3)); }
  .badge-name { font-size:12px; font-weight:700; color:#E0E0E0; }
  .badge-desc { font-size:10px; color:#90A4AE; margin-top:2px; }
  #gallery { background:linear-gradient(160deg,#0a0e27 0%,#0d1b2a 40%,#1a2a4a 100%); padding:24px; gap:14px; }
  .gallery-grid { display:flex; flex-direction:column; gap:12px; max-width:520px; margin:0 auto; width:100%; }
  .gallery-card {
    padding:16px; border-radius:16px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08);
    box-shadow:0 3px 12px rgba(0,0,0,.2); display:flex; align-items:center; gap:14px; backdrop-filter:blur(8px);
  }
  .gallery-card.locked { opacity:.3; }
  .gallery-icon { font-size:40px; flex-shrink:0; filter:drop-shadow(0 2px 6px rgba(0,0,0,.3)); }
  .gallery-info { flex:1; }
  .gallery-name { font-size:15px; font-weight:700; color:#E0E0E0; }
  .gallery-loc { font-size:11px; color:#90A4AE; }
  .gallery-fact { font-size:12px; color:#B0BEC5; margin-top:4px; line-height:1.4; }
  .buddy-wrap { position:absolute; bottom:12px; left:8px; display:flex; align-items:flex-end; gap:6px; z-index:15; pointer-events:none; transition:opacity .3s; }
  .buddy-char { font-size:28px; filter:drop-shadow(0 2px 4px rgba(0,0,0,.3)); animation:buddyBounce 2s ease-in-out infinite; }
  @keyframes buddyBounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-4px)} }
  .buddy-bubble {
    background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.2); border-radius:12px 12px 12px 4px; padding:6px 10px;
    font-size:11px; font-weight:600; color:#E0E0E0; max-width:180px; box-shadow:0 2px 8px rgba(0,0,0,.3);
    animation:bubbleFade .3s ease-out; backdrop-filter:blur(12px);
  }
  @keyframes bubbleFade { from{opacity:0;transform:translateY(5px)} to{opacity:1;transform:translateY(0)} }
  .whatif-panel {
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:16px; max-width:410px; width:100%;
    box-shadow:0 4px 16px rgba(0,0,0,.3); text-align:left; backdrop-filter:blur(8px);
  }
  .whatif-panel h4 { font-size:15px; font-weight:800; color:#E0E0E0; margin-bottom:10px; text-align:center; }
  .whatif-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
  .whatif-row label { font-size:12px; font-weight:700; color:#B0BEC5; width:70px; flex-shrink:0; }
  .whatif-row input[type=range] { flex:1; accent-color:#42A5F5; }
  .whatif-row .val { font-size:12px; font-weight:700; color:#90A4AE; width:40px; text-align:right; }
  .player-banner {
    display:none; padding:6px 12px; border-radius:10px; text-align:center; font-size:13px; font-weight:800;
    flex-shrink:0;
  }
  .player-banner.active { display:block; }
  .player-banner.p1 { background:rgba(33,150,243,.15); color:#64B5F6; border:2px solid rgba(33,150,243,.3); }
  .player-banner.p2 { background:rgba(233,30,99,.15); color:#F48FB1; border:2px solid rgba(233,30,99,.3); }
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div id="app">

  <!-- MENU -->
  <div id="menu" class="screen active">
    <div class="bg-icons" id="bgIcons"></div>
    <div style="font-size:min(18vw,72px);z-index:1">ğŸ—ï¸</div>
    <h1>BUILD LAB</h1>
    <div class="subtitle">Design. Build. Engineer!</div>
    <div class="star-count" id="menuStars" style="display:none">â˜… <span id="menuStarNum">0</span> Stars</div>
    <button class="btn btn-lg btn-orange" onclick="showScreen('worlds')" style="z-index:1;margin-top:8px;">START BUILDING</button>
    <button class="btn btn-md btn-purple" onclick="showScreen('badges')" style="z-index:1">ğŸ† Badges</button>
    <button class="btn btn-md btn-teal" onclick="startDailyChallenge()" style="z-index:1">ğŸ“… Daily Challenge</button>
    <button class="btn btn-md btn-blue" onclick="showScreen('gallery')" style="z-index:1">ğŸŒ Gallery</button>
    <div style="display:flex;gap:8px;z-index:1">
      <button class="btn btn-sm btn-red" onclick="startH2H()" style="flex:1">âš”ï¸ Head-to-Head</button>
      <button class="btn btn-sm btn-green" onclick="startCoOp()" style="flex:1">ğŸ¤ Co-op Build</button>
    </div>
    <div class="age-note">Built for curious minds ages 8+</div>
    <button class="btn btn-sm btn-gray" onclick="sfx.muted=!sfx.muted;this.textContent=sfx.muted?'ğŸ”‡ Sound Off':'ğŸ”Š Sound On'" style="z-index:1;margin-top:4px">ğŸ”Š Sound On</button>
  </div>

  <!-- WORLDS -->
  <div id="worlds" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
      <div style="color:#FFD700;font-size:18px;font-weight:700">â˜… <span id="worldStars">0</span></div>
    </div>
    <h2 style="text-align:center;font-size:28px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(66,165,245,.3)">Choose Your World</h2>
    <div class="worlds-grid" id="worldsGrid"></div>
  </div>

  <!-- LEVELS -->
  <div id="levels" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('worlds')">â† Worlds</button>
      <div style="color:#FFD700;font-size:18px;font-weight:700">â˜… <span id="levelStars">0</span></div>
    </div>
    <h2 id="levelsTitle" style="text-align:center;font-size:26px;font-weight:800;color:#212121"></h2>
    <p id="levelsDesc" style="text-align:center;font-size:14px;color:#757575;margin-bottom:6px"></p>
    <div id="levelList" style="display:flex;flex-direction:column;gap:12px;max-width:500px;margin:0 auto;width:100%"></div>
  </div>

  <!-- INTRO -->
  <div id="intro" class="screen">
    <div class="intro-emoji" id="introEmoji"></div>
    <div class="intro-title" id="introTitle"></div>
    <div class="intro-desc" id="introDesc"></div>
    <div class="tip-card"><div class="label">ğŸ’¡ TIP</div><div class="body" id="introTip"></div></div>
    <div class="fact-card"><div class="label">ğŸ“š DID YOU KNOW?</div><div class="body" id="introFact"></div></div>
    <button class="btn btn-lg btn-green" onclick="startGame()" style="margin-top:8px">LET'S BUILD! ğŸ”¨</button>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="game-topbar">
      <button class="btn btn-sm btn-gray" onclick="exitGame()" style="padding:6px 12px">â† Back</button>
      <div style="text-align:center">
        <div class="title" id="gameTitle"></div>
        <div class="meta" id="gameMeta"></div>
      </div>
      <div style="display:flex;gap:5px">
        <button class="btn btn-sm btn-orange" id="rotateBtn" onclick="rotateSelected()" style="padding:6px 10px;display:none" title="Rotate beam 45Â°">ğŸ”„</button>
        <button class="btn btn-sm btn-purple" onclick="toggleHelp()" style="padding:6px 10px">â“</button>
        <button class="btn btn-sm btn-red" id="clearBtn" onclick="clearBeams()" style="padding:6px 12px">Clear</button>
      </div>
    </div>
    <div class="player-banner" id="playerBanner"></div>
    <div class="hint-banner" id="hintBanner">
      <span class="hlabel">ğŸ’¡ HINT: </span>
      <span class="htext" id="hintBannerText"></span>
    </div>
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="gameCanvas"></canvas>
      <div class="help-overlay" id="helpOverlay">
        <div class="help-box">
          <div class="hicon">ğŸ”¨</div>
          <h3>How to Build</h3>
          <p id="helpText">
            <b>1.</b> Tap a dot to select it<br>
            <b>2.</b> Tap a nearby dot to place a beam<br>
            <b>3.</b> Double-tap a beam to remove it<br>
            <b>4.</b> Hit <b>TEST IT!</b> when ready
          </p>
          <button class="btn btn-md btn-orange" onclick="toggleHelp()">Got it!</button>
        </div>
      </div>
      <div class="buddy-wrap" id="buddyWrap">
        <div class="buddy-char">ğŸ‘·</div>
        <div class="buddy-bubble" id="buddyBubble">Let's build something awesome!</div>
      </div>
      <div class="failure-overlay" id="failureOverlay">
        <div class="failure-box">
          <div class="ficon">ğŸ”</div>
          <h3>What Went Wrong</h3>
          <p class="cause" id="failureCause"></p>
          <div class="hint-card">
            <div class="hlabel">ğŸ’¡ HINT</div>
            <div class="hbody" id="failureHint"></div>
          </div>
          <button class="btn btn-md btn-orange" onclick="continueAfterFailure()">Try Again ğŸ”„</button>
        </div>
      </div>
    </div>
    <div class="game-bottombar" id="bottomBar">
      <div style="display:flex;gap:6px" id="matBtns"></div>
      <button class="btn btn-md btn-green" id="testBtn" onclick="startTest()" disabled>TEST IT! ğŸš›</button>
    </div>
    <div id="testingBar" style="display:none;padding:8px 12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.1);border-radius:14px;text-align:center;flex-shrink:0;backdrop-filter:blur(8px)">
      <div style="font-size:15px;font-weight:700;color:#E0E0E0;margin-bottom:6px" id="testingLabel">ğŸš› Testing your bridge...</div>
      <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
    </div>
  </div>

  <!-- GALLERY -->
  <div id="gallery" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
    </div>
    <h2 style="text-align:center;font-size:26px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(33,150,243,.3)">ğŸŒ Real-World Structures</h2>
    <p style="text-align:center;font-size:14px;color:#90A4AE">Complete levels to unlock real engineering marvels!</p>
    <div class="gallery-grid" id="galleryGrid"></div>
  </div>

  <!-- BADGES -->
  <div id="badges" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
      <div style="font-size:18px;font-weight:700;color:#FF8F00" id="badgeCount">0 / 0</div>
    </div>
    <h2 style="text-align:center;font-size:26px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(255,215,0,.3)">ğŸ† Builder Badges</h2>
    <p style="text-align:center;font-size:14px;color:#90A4AE">Complete challenges to earn badges!</p>
    <div class="badges-grid" id="badgesGrid"></div>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen">
    <div class="result-emoji" id="resultEmoji"></div>
    <div class="result-title" id="resultTitle"></div>
    <div id="resultStars" class="stars" style="justify-content:center"></div>
    <div class="principle-card" id="principleCard" style="display:none">
      <div class="label" id="principleLabel"></div>
      <div class="body" id="principleBody"></div>
    </div>
    <div class="result-hint" id="resultHint"></div>
    <div id="whatIfPanel" class="whatif-panel" style="display:none">
      <h4>ğŸ”¬ What If...?</h4>
      <div class="whatif-row"><label>Gravity</label><input type="range" id="wifGravity" min="1" max="200" value="100" oninput="document.getElementById('wifGravVal').textContent=this.value+'%'"><span class="val" id="wifGravVal">100%</span></div>
      <div class="whatif-row"><label>Weight</label><input type="range" id="wifWeight" min="25" max="300" value="100" oninput="document.getElementById('wifWeightVal').textContent=this.value+'%'"><span class="val" id="wifWeightVal">100%</span></div>
      <div class="whatif-row"><label>Wind</label><input type="range" id="wifWind" min="0" max="200" value="0" oninput="document.getElementById('wifWindVal').textContent=this.value+'%'"><span class="val" id="wifWindVal">0%</span></div>
      <button class="btn btn-sm btn-teal" onclick="runWhatIf()" style="width:100%;margin-top:4px">Re-Test with These Settings! ğŸ§ª</button>
    </div>
    <div class="result-btns" id="resultBtns"></div>
    <button class="back-link" onclick="showScreen('levels')">Back to Levels</button>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD LAB â€” Complete Game Engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ WORLD DATA â”€â”€
const WORLD_DATA = [
  {
    id:'bridges', name:'Bridges', emoji:'ğŸŒ‰', color:'#2196F3',
    desc:'Build bridges that hold!', testType:'vehicle',
    btnClass:'btn-blue', testLabel:'ğŸš› Testing your bridge...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap a nearby dot to place a beam<br><b>3.</b> Double-tap a beam to remove it<br><b>4.</b> Hit <b>TEST IT!</b> when ready',
    materials:{ wood:{ name:"Wood",color:"#A1887F",stroke:"#6D4C41",maxStress:0.35,width:8,emoji:"ğŸªµ",cost:1 }, steel:{ name:"Steel",color:"#78909C",stroke:"#455A64",maxStress:0.65,width:6,emoji:"ğŸ”©",cost:2 }},
    levels:[
      { id:1,name:"First Bridge",subtitle:"Learn the basics!",description:"Connect the two sides to help the truck cross the river!",tip:"Tap a dot, then tap another nearby dot to place a beam between them.",fact:"The oldest known bridge is over 3,000 years old! Ancient people used fallen trees to cross rivers.",emoji:"ğŸŒ‰",gridW:8,gridH:5,cellSize:65,anchors:[[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[6,2],[6,3],[6,4],[7,2],[7,3],[7,4]],groundTiles:[[0,3],[0,4],[1,3],[1,4],[6,3],[6,4],[7,3],[7,4]],waterTiles:[[2,3],[2,4],[3,3],[3,4],[4,3],[4,4],[5,3],[5,4]],roadY:2,roadStartX:0,roadEndX:7,par:8,vehicleWeight:2.5,vehicleSpeed:1.2,principle:"Beams transfer weight to supports on each side.",principleIcon:"ğŸ“" },
      { id:2,name:"Triangle Power",subtitle:"The strongest shape!",description:"This gap is wider! You'll need triangles to make your bridge strong enough.",tip:"Triangles can't be squished out of shape â€” try adding diagonal beams!",fact:"The Eiffel Tower is made of 18,038 iron pieces connected in triangles. That's what makes it so strong!",emoji:"ğŸ—¼",gridW:9,gridH:6,cellSize:58,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[7,2],[7,3],[7,4],[7,5],[8,2],[8,3],[8,4],[8,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5],[6,3],[6,4],[6,5]],roadY:2,roadStartX:0,roadEndX:8,par:14,vehicleWeight:3.0,vehicleSpeed:1.0,principle:"Triangles are the strongest shape in engineering!",principleIcon:"ğŸ”º" },
      { id:3,name:"The Pillar",subtitle:"Build UP to go ACROSS!",description:"Use the rock in the middle of the river as a support pillar!",tip:"Pillars push weight straight down. Build down to the rock, then bridge across!",fact:"Ancient Romans built aqueducts with tall pillars â€” some still work 2,000 years later!",emoji:"ğŸ›ï¸",gridW:10,gridH:6,cellSize:52,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[8,2],[8,3],[8,4],[8,5],[9,2],[9,3],[9,4],[9,5],[4,4],[4,5],[5,4],[5,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[8,3],[8,4],[8,5],[9,3],[9,4],[9,5],[4,4],[4,5],[5,4],[5,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[6,3],[6,4],[6,5],[7,3],[7,4],[7,5]],roadY:2,roadStartX:0,roadEndX:9,par:18,vehicleWeight:3.5,vehicleSpeed:0.9,principle:"Pillars carry weight straight down â€” the shorter the pillar, the stronger!",principleIcon:"ğŸ—ï¸" },
      { id:4,name:"Heavy Hauler",subtitle:"Can your bridge handle it?",description:"A super heavy truck needs to cross! Steel beams might help.",tip:"Steel is stronger than wood but costs more. Use steel where the load is heaviest!",fact:"The Golden Gate Bridge holds 4,000 vehicles at once! Its cables have 80,000 miles of steel wire.",emoji:"ğŸŒ",gridW:9,gridH:6,cellSize:58,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[7,2],[7,3],[7,4],[7,5],[8,2],[8,3],[8,4],[8,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5],[6,3],[6,4],[6,5]],roadY:2,roadStartX:0,roadEndX:8,par:16,vehicleWeight:5.5,vehicleSpeed:0.7,principle:"Engineers pick the right material for each job!",principleIcon:"ğŸ’ª" },
      { id:5,name:"Master Builder",subtitle:"The ultimate challenge!",description:"A deep canyon with tricky terrain. Use everything you've learned!",tip:"Combine triangles, pillars, and smart material choices!",fact:"The Millau Viaduct in France is taller than the Eiffel Tower! Engineers spent 3 years building it.",emoji:"ğŸ”ï¸",gridW:11,gridH:7,cellSize:48,anchors:[[0,2],[0,3],[0,4],[0,5],[0,6],[1,2],[1,3],[1,4],[1,5],[1,6],[9,3],[9,4],[9,5],[9,6],[10,3],[10,4],[10,5],[10,6],[5,5],[5,6]],groundTiles:[[0,3],[0,4],[0,5],[0,6],[1,3],[1,4],[1,5],[1,6],[9,4],[9,5],[9,6],[10,4],[10,5],[10,6],[5,5],[5,6]],waterTiles:[[2,4],[2,5],[2,6],[3,4],[3,5],[3,6],[4,4],[4,5],[4,6],[6,4],[6,5],[6,6],[7,4],[7,5],[7,6],[8,4],[8,5],[8,6]],roadY:2,roadStartX:0,roadEndX:10,par:24,vehicleWeight:4.5,vehicleSpeed:0.8,principle:"Real engineers combine triangles, pillars, and smart materials!",principleIcon:"ğŸ“" }
    ]
  },
  {
    id:'towers', name:'Towers', emoji:'ğŸ°', color:'#7C4DFF',
    desc:'Stack high & stay stable!', testType:'weight',
    btnClass:'btn-purple', testLabel:'â¬‡ï¸ Dropping the weight...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap another dot to place a beam<br><b>3.</b> Build UP from the ground to the target line<br><b>4.</b> Hit <b>TEST IT!</b> when ready',
    materials:{ wood:{ name:"Wood",color:"#A1887F",stroke:"#6D4C41",maxStress:0.35,width:8,emoji:"ğŸªµ",cost:1 }, steel:{ name:"Steel",color:"#78909C",stroke:"#455A64",maxStress:0.65,width:6,emoji:"ğŸ”©",cost:2 }},
    levels:[
      { id:1,name:"Pyramid of Giza",subtitle:"Build like the pharaohs! ğŸ”º",description:"The Great Pyramid stood for 4,500 years! Build a wide-based tower using ONLY diagonal beams â€” no horizontal allowed!",tip:"Diagonal beams form triangles, which are the strongest shape. The pyramid shape pushes weight outward and down!",fact:"The Great Pyramid contains 2.3 million stone blocks, each weighing 2.5 tons. Its wide base is why it still stands!",emoji:"ğŸ”º",gridW:5,gridH:7,cellSize:60,anchors:[[0,5],[1,5],[2,5],[3,5],[4,5]],groundTiles:[[0,6],[1,6],[2,6],[3,6],[4,6]],waterTiles:[],targetRow:1,par:10,testWeight:2.0,buildingShape:'pyramid',principle:"A wide base distributes weight evenly â€” that's why pyramids are nearly indestructible!",principleIcon:"ğŸ”º" },
      { id:2,name:"Eiffel Tower",subtitle:"Iron lattice of Paris! ğŸ—¼",description:"Gustave Eiffel used TRIANGULAR lattice to make a tower from thin iron. Build with triangles â€” they're the secret!",tip:"The Eiffel Tower is 80% empty air! Triangular trusses make it incredibly strong with minimal material.",fact:"The Eiffel Tower uses 18,038 iron pieces joined by 2.5 million rivets. Triangles everywhere!",emoji:"ğŸ—¼",gridW:5,gridH:8,cellSize:55,anchors:[[0,6],[1,6],[2,6],[3,6],[4,6]],groundTiles:[[0,7],[1,7],[2,7],[3,7],[4,7]],waterTiles:[],targetRow:1,par:14,testWeight:3.0,buildingShape:'eiffel',principle:"Triangles are rigid â€” they can't be squished like rectangles. That's why the Eiffel Tower uses them everywhere!",principleIcon:"ğŸ—¼" },
      { id:3,name:"Taipei 101",subtitle:"Tame the typhoon! ğŸŒªï¸",description:"Taipei 101 faces powerful typhoons! Build a tower with cross-bracing to resist the fierce wind.",tip:"Cross-bracing (X shapes) fights sideways forces. Taipei 101 also has a giant pendulum that swings to absorb wind energy!",fact:"Taipei 101 has a 728-ton golden pendulum (tuned mass damper) that reduces swaying by 40%!",emoji:"ğŸŒªï¸",gridW:6,gridH:8,cellSize:52,anchors:[[0,6],[1,6],[2,6],[3,6],[4,6],[5,6]],groundTiles:[[0,7],[1,7],[2,7],[3,7],[4,7],[5,7]],waterTiles:[],targetRow:1,par:16,testWeight:2.5,windForce:0.18,buildingShape:'taipei',principle:"Cross-bracing and dampers help skyscrapers resist sideways forces like wind and earthquakes!",principleIcon:"ğŸŒªï¸" },
      { id:4,name:"Burj Khalifa",subtitle:"World's tallest! ğŸ™ï¸",description:"At 2,717 feet, the Burj Khalifa is the tallest building ever! Build tall using a BUDGET: Wood=1 coin, Steel=3 coins. Budget: 30 coins.",tip:"The Burj Khalifa uses a Y-shaped core for stability. Use steel only where stress is highest â€” be smart with your budget!",fact:"The Burj Khalifa took 6 years and 12,000 workers. Its Y-shape reduces wind force by 25%!",emoji:"ğŸ™ï¸",gridW:7,gridH:9,cellSize:48,anchors:[[0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],groundTiles:[[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],waterTiles:[],targetRow:1,par:22,testWeight:4.0,windForce:0.1,budget:30,buildingShape:'burj',principle:"Real skyscrapers combine strong cores, cross-bracing, and smart material choices to reach incredible heights!",principleIcon:"ğŸ™ï¸" }
    ]
  },
  {
    id:'arches', name:'Arches', emoji:'ğŸ›ï¸', color:'#009688',
    desc:'Build with curved stone!', testType:'arch',
    btnClass:'btn-teal', testLabel:'â¬‡ï¸ Dropping the weight...',
    helpText:'<b>1.</b> Tap the ghost stones to place them<br><b>2.</b> Place the <span style="color:#FFD600">â˜… keystone</span> last to lock the arch!<br><b>3.</b> Hit <b>TEST IT!</b> to drop the weight<br><b>4.</b> A complete arch pushes weight to the sides!',
    materials:{ stone:{ name:"Stone",color:"#8D6E63",stroke:"#5D4037",maxStress:0.40,width:9,emoji:"ğŸª¨",cost:1 }, marble:{ name:"Marble",color:"#B0BEC5",stroke:"#607D8B",maxStress:0.70,width:7,emoji:"ğŸ’",cost:2 }},
    levels:[
      { id:1,name:"First Arch",subtitle:"The shape that holds!",description:"Tap a stone to auto-fill the arch, then place the golden KEYSTONE to lock it!",tip:"The keystone at the very top is the most important stone â€” it wedges between the two sides and locks everything together!",fact:"Romans built arches from wedge-shaped stones called voussoirs. Many still stand 2,000 years later!",emoji:"ğŸ›ï¸",
        archType:'roman',archCx:240,archCy:260,archRx:170,archRy:150,archSlots:7,archPillarW:50,archPillarH:100,canvasW:480,canvasH:370,testWeight:3.0,par:7,autoFill:true,
        principle:"Each stone in an arch pushes on its neighbor. The keystone at the top locks them all together!",principleIcon:"ğŸ›ï¸" },
      { id:2,name:"Roman Gate",subtitle:"Build a grand entrance!",description:"A wider arch needs more stones. Tap to fill, then lock it with the keystone!",tip:"More stones make a smoother, stronger curve. The weight flows through every stone to the pillars!",fact:"Roman aqueducts carried water across valleys using rows of arches. The Pont du Gard is 160 feet tall!",emoji:"ğŸº",
        archType:'roman',archCx:270,archCy:280,archRx:210,archRy:170,archSlots:9,archPillarW:55,archPillarH:110,canvasW:540,canvasH:400,testWeight:4.0,par:9,autoFill:true,
        principle:"A wider arch needs more stones but spreads weight over a bigger area â€” that's why aqueducts work!",principleIcon:"ğŸ”‘" },
      { id:3,name:"Gothic Point",subtitle:"Reach to the heavens!",description:"Gothic cathedrals used POINTED arches â€” they're stronger AND taller than round ones! Build one!",tip:"A pointed arch directs weight downward more efficiently. Notice how the peak is sharp, not round!",fact:"Gothic cathedrals like Notre-Dame use pointed arches and flying buttresses to reach incredible heights!",emoji:"â›ª",
        archType:'gothic',archCx:260,archCy:300,archRx:170,archRy:200,archSlots:9,archPillarW:55,archPillarH:100,canvasW:520,canvasH:420,testWeight:4.5,par:9,autoFill:true,
        principle:"Pointed arches direct forces more straight down, letting builders reach incredible heights!",principleIcon:"â›ª" },
      { id:4,name:"The Aqueduct",subtitle:"Double arch power!",description:"Build TWO arches on a shared middle pillar â€” just like a real Roman aqueduct!",tip:"The middle pillar supports both arches. Two smaller arches are stronger than one big one!",fact:"The Romans built aqueducts spanning hundreds of miles. The Aqueduct of Segovia has 163 arches!",emoji:"ğŸŒŠ",
        archType:'double',archCx:200,archCx2:430,archCy:280,archRx:140,archRy:150,archSlots:7,archPillarW:45,archPillarH:100,canvasW:630,canvasH:390,testWeight:5.0,par:15,autoFill:true,
        principle:"Dividing a long span into multiple arches with shared pillars multiplies the strength!",principleIcon:"ğŸ—ï¸" }
    ]
  },
  {
    id:'circuits', name:'Circuits', emoji:'âš¡', color:'#E91E63',
    desc:'Wire up & power on!', testType:'circuit',
    btnClass:'btn-pink', testLabel:'âš¡ Sending electricity...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap another dot to place a wire<br><b>3.</b> Connect the ğŸ”‹ battery to all ğŸ’¡ bulbs<br><b>4.</b> Hit <b>TEST IT!</b> to send power!',
    materials:{ copper:{ name:"Copper",color:"#FF9800",stroke:"#E65100",maxStress:1,width:6,emoji:"ğŸ”Œ",cost:1 }, fiber:{ name:"Fiber",color:"#00BCD4",stroke:"#006064",maxStress:1,width:4,emoji:"ğŸ’",cost:2 }},
    levels:[
      { id:1,name:"Light It Up",subtitle:"Complete the circuit!",description:"Connect the battery to the light bulb to turn it on!",tip:"Electricity needs a complete path â€” connect dots from the battery all the way to the bulb.",fact:"Thomas Edison tested over 3,000 designs before finding the right light bulb filament!",emoji:"ğŸ’¡",gridW:6,gridH:3,cellSize:80,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,1]],targets:[[5,1]],blocked:[],par:5,principle:"A circuit needs an unbroken path from power source to device!",principleIcon:"âš¡" },
      { id:2,name:"Two Lights",subtitle:"Power them both!",description:"One battery, two bulbs. Can you wire them both?",tip:"You can branch your wires â€” split the path to reach both bulbs!",fact:"In your house, most outlets run in parallel circuits. That way if one light goes out, the others stay on!",emoji:"ğŸ’¡ğŸ’¡",gridW:7,gridH:5,cellSize:65,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,2]],targets:[[6,0],[6,4]],blocked:[],par:8,principle:"Parallel circuits let multiple devices share one power source!",principleIcon:"ğŸ”€" },
      { id:3,name:"Around the Block",subtitle:"Find a path!",description:"Obstacles block the direct route. Wire around them to reach the bulb!",tip:"You can't go through the red blocks â€” find a path around them!",fact:"Circuit board designers use clever routing to fit thousands of connections on a tiny chip!",emoji:"ğŸ§©",gridW:7,gridH:5,cellSize:65,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,2]],targets:[[6,2]],blocked:[[2,1],[2,2],[2,3],[4,1],[4,2],[4,3]],par:8,principle:"Engineers route circuits around obstacles â€” just like solving a maze!",principleIcon:"ğŸ§©" },
      { id:4,name:"Power Grid",subtitle:"Light up the city!",description:"Multiple batteries, multiple bulbs. Design an efficient power grid!",tip:"Plan your routes carefully â€” try to share wires between different paths.",fact:"The US power grid is the largest machine ever built, with over 450,000 miles of transmission lines!",emoji:"ğŸ™ï¸",gridW:8,gridH:6,cellSize:58,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,1],[0,4]],targets:[[7,0],[7,3],[7,5]],blocked:[[3,0],[3,1],[3,4],[3,5],[5,1],[5,2],[5,3],[5,4]],par:12,principle:"Smart grid design minimizes wires while keeping everything powered!",principleIcon:"ğŸŒ" }
    ]
  },
  {
    id:'castle', name:'Castle', emoji:'ğŸ°', color:'#FF8F00',
    desc:'Build a mighty fortress!', testType:'castle',
    btnClass:'btn-amber', testLabel:'â¬‡ï¸ Testing the castle...',
    helpText:'<b>Castle</b> combines everything you know!<br>Build arches, towers, and wire circuits.<br>Each level tests different skills!',
    materials:{ wood:{ name:"Wood",color:"#A1887F",stroke:"#6D4C41",maxStress:0.35,width:8,emoji:"ğŸªµ",cost:1 }, steel:{ name:"Steel",color:"#78909C",stroke:"#455A64",maxStress:0.65,width:6,emoji:"ğŸ”©",cost:2 }, stone:{ name:"Stone",color:"#8D6E63",stroke:"#5D4037",maxStress:0.50,width:9,emoji:"ğŸª¨",cost:1 }},
    levels:[
      { id:1,name:"Castle Gate",subtitle:"Build the grand entrance! ğŸ°",
        description:"Every castle needs a strong gate! Build a stone arch doorway, then a weight drops to test if it holds. Choose wisely: round or pointed arch?",
        tip:"Pointed arches direct weight downward more efficiently â€” they're stronger for heavy loads!",
        fact:"Medieval castle gates often used portcullis (heavy sliding doors) protected by pointed Gothic arches!",
        emoji:"ğŸšª",castlePhase:'arch',
        archType:'gothic',archCx:260,archCy:280,archRx:180,archRy:180,archSlots:9,archPillarW:55,archPillarH:100,canvasW:520,canvasH:400,testWeight:5.0,par:9,autoFill:true,
        principle:"Gothic pointed arches are stronger than round ones for heavy loads â€” that's why castles used them!",principleIcon:"ğŸ°" },
      { id:2,name:"Watchtower",subtitle:"See the enemy coming! ğŸ—¼",
        description:"Build a tall watchtower on the castle wall! Wind howls across the battlements â€” brace it well! Budget: Wood=1, Steel=3, Total: 25 coins.",
        tip:"A watchtower needs a wide base AND cross-bracing. Wind is your biggest enemy up high!",
        fact:"Medieval watchtowers could see enemies 20 miles away! The Tower of London's White Tower is 90 feet tall.",
        emoji:"ğŸ—¼",castlePhase:'tower',
        gridW:5,gridH:8,cellSize:55,anchors:[[0,6],[1,6],[2,6],[3,6],[4,6]],groundTiles:[[0,7],[1,7],[2,7],[3,7],[4,7]],waterTiles:[],
        targetRow:1,par:14,testWeight:3.0,windForce:0.2,budget:25,
        principle:"Watchtowers need wide bases AND cross-bracing to resist wind at great heights!",principleIcon:"ğŸ—¼" },
      { id:3,name:"Great Hall",subtitle:"Light up the feast! âš¡",
        description:"Wire up the torches in the Great Hall! Connect the generator to all the torch sconces. Plan your wire paths carefully!",
        tip:"Like medieval torch lighting, you need efficient paths. Share wire routes where possible!",
        fact:"Medieval great halls could seat hundreds! They used torches, candles, and fireplaces for light and warmth.",
        emoji:"ğŸ”¥",castlePhase:'circuit',
        gridW:7,gridH:5,cellSize:65,anchors:[],groundTiles:[],waterTiles:[],
        sources:[[0,2]],targets:[[6,0],[6,2],[6,4]],blocked:[[2,0],[2,1],[4,3],[4,4]],par:10,
        principle:"Efficient wiring lights up more with less â€” medieval engineers had to plan torch placement carefully!",principleIcon:"ğŸ”¥" },
      { id:4,name:"The Full Castle",subtitle:"The ultimate challenge! ğŸ‘‘",
        description:"Build the tallest, strongest castle keep! Use all your engineering knowledge. Wind, weight, and a tight budget: 35 coins!",
        tip:"Combine everything: wide base like a pyramid, triangles like the Eiffel Tower, and cross-bracing for wind!",
        fact:"The largest medieval castle is Malbork Castle in Poland â€” it covers 52 acres and took 230 years to build!",
        emoji:"ğŸ‘‘",castlePhase:'tower',
        gridW:7,gridH:9,cellSize:48,anchors:[[0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],groundTiles:[[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],waterTiles:[],
        targetRow:1,par:24,testWeight:5.0,windForce:0.22,budget:35,buildingShape:'burj',
        principle:"Master engineers combine every principle: strong base, triangular bracing, smart materials, and efficient design!",principleIcon:"ğŸ‘‘" }
    ]
  },
  {
    id:'flying', name:'Flying', emoji:'âœˆï¸', color:'#00BCD4',
    desc:'Master the physics of flight!', testType:'flight',
    btnClass:'btn-cyan', testLabel:'âœˆï¸ Launching flight test...',
    helpText:'<b>1.</b> Build a wing shape by connecting dots<br><b>2.</b> Angled beams create LIFT (â†— not â†’)<br><b>3.</b> Wider wings = more lift!<br><b>4.</b> Hit <b>TEST IT!</b> to launch!',
    materials:{ aluminum:{ name:"Aluminum",color:"#B0BEC5",stroke:"#78909C",maxStress:0.45,width:7,emoji:"ğŸ”§",cost:1 }, carbon:{ name:"Carbon Fiber",color:"#37474F",stroke:"#263238",maxStress:0.80,width:5,emoji:"âš¡",cost:2 }},
    levels:[
      { id:1,name:"First Flight",subtitle:"The Wright way! âœˆï¸",
        description:"The Wright Brothers proved that curved wings create lift! Build a wing shape that's wider on top and angled upward. The wind will do the rest!",
        tip:"Angle your beams slightly upward (â†—) â€” flat beams don't create lift! The curve of a wing pushes air down, and the reaction pushes YOU up!",
        fact:"The Wright Brothers' first flight in 1903 lasted just 12 seconds and covered 120 feet â€” shorter than a Boeing 747!",
        emoji:"ğŸ›©ï¸",gridW:7,gridH:5,cellSize:65,
        anchors:[[0,2],[0,3],[0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4]],
        groundTiles:[],waterTiles:[],
        flightTarget:100,windSpeed:1.0,par:8,
        principle:"Wings create lift because curved tops make air move faster â€” reducing pressure above and pushing the wing UP! (Bernoulli's principle)",principleIcon:"âœˆï¸" },
      { id:2,name:"Glider Design",subtitle:"Soar without an engine! ğŸª‚",
        description:"Design a glider with long wings! Longer wingspan = more lift. But watch out â€” too many beams add weight and drag!",
        tip:"Long, thin wings are best for gliders. Every extra beam adds weight â€” keep it light but strong!",
        fact:"The longest glider flight lasted over 76 hours! Gliders use rising warm air (thermals) to stay aloft for days.",
        emoji:"ğŸª‚",gridW:9,gridH:5,cellSize:55,
        anchors:[[0,2],[0,3],[0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4]],
        groundTiles:[],waterTiles:[],
        flightTarget:200,windSpeed:1.2,par:12,
        principle:"Longer wings create more lift but add weight. Engineers balance wingspan vs. weight â€” it's called aspect ratio!",principleIcon:"ğŸª‚" },
      { id:3,name:"Headwind Hero",subtitle:"Fight the storm! ğŸŒªï¸",
        description:"A strong headwind is blowing! Build a streamlined shape â€” bulky structures create drag and slow you down!",
        tip:"Streamlined shapes (like a teardrop) cut through air. Avoid flat surfaces facing the wind â€” they create drag!",
        fact:"A golf ball's dimples reduce drag by creating a thin layer of turbulent air. Airplanes use a similar trick with vortex generators!",
        emoji:"ğŸŒªï¸",gridW:8,gridH:5,cellSize:58,
        anchors:[[0,2],[0,3],[0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4]],
        groundTiles:[],waterTiles:[],
        flightTarget:150,windSpeed:2.0,dragMult:1.5,par:10,
        principle:"Drag fights against motion. Streamlined shapes minimize drag â€” that's why planes are pointy, not flat!",principleIcon:"ğŸŒªï¸" },
      { id:4,name:"Supersonic Dream",subtitle:"Break the sound barrier! ğŸš€",
        description:"Design the ultimate aircraft! You need maximum lift with minimum drag. Budget: Aluminum=1, Carbon Fiber=3, Total: 28 coins.",
        tip:"Swept-back wings reduce drag at high speeds. Use carbon fiber for the main wing spars â€” they're lighter AND stronger!",
        fact:"The SR-71 Blackbird flew at Mach 3.3 (2,200 mph). Its titanium body would expand 6 inches from friction heat!",
        emoji:"ğŸš€",gridW:9,gridH:6,cellSize:52,
        anchors:[[0,3],[0,4],[0,5],[1,5],[2,5],[3,5],[4,5],[5,5],[6,5],[7,5],[8,5]],
        groundTiles:[],waterTiles:[],
        flightTarget:300,windSpeed:2.5,dragMult:2.0,budget:28,par:14,
        principle:"At supersonic speeds, swept wings and lightweight materials are essential. Every gram of weight and every bit of drag matters!",principleIcon:"ğŸš€" }
    ]
  }
];

// â”€â”€ PHYSICS CONSTANTS â”€â”€
const GRAVITY = 0.4, DAMPING = 0.98, ITERATIONS = 8, BREAK_MULT = 2.5;

// â”€â”€ STATE â”€â”€
let currentWorld = 0;
let currentLevel = 0;
let earnedStars = {};
let material = '';
let selectedNode = null;
let gameNodes = [];
let gameBeams = [];
let helpVisible = true;
let isTesting = false;
let animId = null;
let vehicle = null;
let canvas, ctx;
let physicsNodes = [], physicsBeams = [];
let failurePhase = null;
let failureFrames = 0;
let failureData = null;
let lastHint = {};
let levelAttempts = {};
let weightObj = null;
let circuitParticles = [];
let circuitReached = new Set();
let flightState = null;

// â”€â”€ PERSISTENCE â”€â”€
function saveProgress() {
  try { localStorage.setItem('buildlab_stars', JSON.stringify(earnedStars)); } catch(e) {}
  try { localStorage.setItem('buildlab_attempts', JSON.stringify(levelAttempts)); } catch(e) {}
  // Hints are session-only now â€” not persisted to avoid stale cross-world tips
}
function loadProgress() {
  try { earnedStars = JSON.parse(localStorage.getItem('buildlab_stars')) || {}; } catch(e) { earnedStars = {}; }
  try { levelAttempts = JSON.parse(localStorage.getItem('buildlab_attempts')) || {}; } catch(e) { levelAttempts = {}; }
  // Clear stale hints from before world-specific fix (v2)
  lastHint = {};
  try { localStorage.removeItem('buildlab_hints'); } catch(e) {}
}

// â”€â”€ HELPERS â”€â”€
function starKey(wi, li) { return `${wi}_${li}`; }
function getTotalStars() { return Object.values(earnedStars).reduce((a,b)=>a+b,0); }
function getWorldStars(wi) {
  const w = WORLD_DATA[wi]; let t=0;
  for (let i=0;i<w.levels.length;i++) t += earnedStars[starKey(wi,i)]||0;
  return t;
}
function starsHTML(c,sz) { sz=sz||28; let h=''; for(let i=0;i<3;i++) h+=`<span class="star ${i<c?'on':'off'}" style="font-size:${sz}px">â˜…</span>`; return h; }
function getLevel() {
  if (window._isDailyChallenge && window._dailyLevel) return window._dailyLevel;
  return WORLD_DATA[currentWorld].levels[currentLevel];
}
function getWorld() { return WORLD_DATA[currentWorld]; }

// â”€â”€ SCREENS â”€â”€
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if (id==='menu') updateMenuStars();
  if (id==='worlds') renderWorlds();
  if (id==='levels') renderLevels();
  if (id==='badges') renderBadges();
  if (id==='gallery') renderGallery();
}

function updateMenuStars() {
  const total = getTotalStars();
  const el = document.getElementById('menuStars');
  const num = document.getElementById('menuStarNum');
  if (total>0) { el.style.display='block'; num.textContent=total; }
  else el.style.display='none';
}

// â”€â”€ WORLDS â”€â”€
function renderWorlds() {
  document.getElementById('worldStars').textContent = getTotalStars();
  const grid = document.getElementById('worldsGrid');
  grid.innerHTML = '';
  WORLD_DATA.forEach((w,i) => {
    const ws = getWorldStars(i);
    const maxS = w.levels.length * 3;
    const card = document.createElement('button');
    card.className = 'world-card';
    card.style.background = `linear-gradient(135deg,${w.color},${w.color}cc)`;
    card.style.boxShadow = `0 6px 20px ${w.color}44`;
    card.innerHTML = `
      <div class="emoji">${w.emoji}</div>
      <div class="wname">${w.name}</div>
      <div class="wdesc">${w.desc}</div>
      <div class="wstars">â˜… ${ws} / ${maxS}</div>
    `;
    card.onclick = () => { currentWorld=i; showScreen('levels'); };
    grid.appendChild(card);
  });
}

// â”€â”€ LEVELS â”€â”€
function renderLevels() {
  const w = getWorld();
  const ws = getWorldStars(currentWorld);
  document.getElementById('levelStars').textContent = ws;
  document.getElementById('levelsTitle').innerHTML = `${w.emoji} ${w.name}`;
  document.getElementById('levelsDesc').textContent = w.desc;
  const list = document.getElementById('levelList');
  list.innerHTML = '';
  w.levels.forEach((l,i) => {
    const sk = starKey(currentWorld,i);
    const unlocked = i===0 || (earnedStars[starKey(currentWorld,i-1)]||0)>0;
    const btn = document.createElement('button');
    btn.className = 'level-btn' + (unlocked?'':' locked');
    btn.innerHTML = `
      <div class="level-num" style="background:${unlocked?`linear-gradient(135deg,${w.color},${w.color}cc)`:'#BDBDBD'}">
        ${unlocked ? l.id : 'ğŸ”’'}
      </div>
      <div class="level-info">
        <div class="level-name">${l.name}</div>
        <div class="level-sub">${l.subtitle}</div>
      </div>
      <div class="stars">${starsHTML(earnedStars[sk]||0, 20)}</div>
    `;
    if (unlocked) btn.onclick = () => showIntro(i);
    list.appendChild(btn);
  });
}

// â”€â”€ INTRO â”€â”€
function showIntro(idx) {
  currentLevel = idx;
  const l = getLevel();
  document.getElementById('introEmoji').textContent = l.emoji;
  document.getElementById('introTitle').textContent = `Level ${l.id}: ${l.name}`;
  document.getElementById('introDesc').textContent = l.description;
  document.getElementById('introTip').textContent = l.tip;
  document.getElementById('introFact').textContent = l.fact;
  showScreen('intro');
}

// â”€â”€ INIT GAME â”€â”€
function startGame() {
  const w = getWorld();
  const l = getLevel();
  const anchorSet = l.anchors ? new Set(l.anchors.map(([x,y])=>`${x},${y}`)) : new Set();
  gameNodes = []; gameBeams = []; selectedNode = null;
  isTesting = false; vehicle = null; weightObj = null;
  failurePhase = null; failureData = null; whatIfOverrides = null;
  circuitParticles = []; circuitReached = new Set();
  archState = null; flightState = null;

  // Set default material
  const matKeys = Object.keys(w.materials);
  material = matKeys[0];

  // Create nodes â€” castle levels route based on castlePhase
  const effectiveType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (effectiveType === 'arch') {
    startArchGame();
  } else if (effectiveType === 'circuit') {
    const blockedSet = new Set((l.blocked||[]).map(([x,y])=>`${x},${y}`));
    const srcSet = new Set((l.sources||[]).map(([x,y])=>`${x},${y}`));
    const tgtSet = new Set((l.targets||[]).map(([x,y])=>`${x},${y}`));
    for (let gx=0; gx<l.gridW; gx++) {
      for (let gy=0; gy<l.gridH; gy++) {
        if (blockedSet.has(`${gx},${gy}`)) continue;
        const isSrc = srcSet.has(`${gx},${gy}`);
        const isTgt = tgtSet.has(`${gx},${gy}`);
        gameNodes.push({ x:60+gx*l.cellSize, y:60+gy*l.cellSize, px:60+gx*l.cellSize, py:60+gy*l.cellSize, fixed:true, gx, gy, nodeType: isSrc?'source':isTgt?'target':'normal' });
      }
    }
  } else {
    for (let gx=0; gx<l.gridW; gx++) {
      for (let gy=0; gy<l.gridH; gy++) {
        const isGround = l.groundTiles.some(([tx,ty])=>tx===gx&&ty===gy);
        const isWater = l.waterTiles && l.waterTiles.some(([tx,ty])=>tx===gx&&ty===gy);
        if (isGround || isWater) continue;
        const fixed = anchorSet.has(`${gx},${gy}`);
        gameNodes.push({ x:40+gx*l.cellSize, y:40+gy*l.cellSize, px:40+gx*l.cellSize, py:40+gy*l.cellSize, fixed, gx, gy, nodeType:'normal' });
      }
    }
  }

  showScreen('game');
  initCanvas();
  updateMaterialBtns();
  updateGameUI();

  // Update help text
  document.getElementById('helpText').innerHTML = w.helpText;
  document.getElementById('helpOverlay').style.display = 'flex';
  helpVisible = true;
  document.getElementById('failureOverlay').classList.remove('active');
  document.getElementById('bottomBar').style.display = 'flex';
  document.getElementById('testingBar').style.display = 'none';
  document.getElementById('testingLabel').textContent = w.testLabel;

  // Show hint banner if we have a previous hint
  const hk = starKey(currentWorld, currentLevel);
  const hintBanner = document.getElementById('hintBanner');
  if (lastHint[hk]) {
    document.getElementById('hintBannerText').textContent = lastHint[hk];
    hintBanner.classList.add('active');
  } else {
    hintBanner.classList.remove('active');
  }

  // Update test button text
  const testBtn = document.getElementById('testBtn');
  const eType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eType === 'circuit') testBtn.innerHTML = 'TEST IT! âš¡';
  else if (eType === 'arch') testBtn.innerHTML = 'TEST IT! â¬‡ï¸';
  else if (eType === 'flight') testBtn.innerHTML = 'LAUNCH! âœˆï¸';
  else if (eType === 'weight' || eType === 'tower') testBtn.innerHTML = 'TEST IT! â¬‡ï¸';
  else testBtn.innerHTML = 'TEST IT! ğŸš›';

  buddy.startTips();
  drawGame();
}

function initCanvas() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
}

function resizeCanvas() {
  const l = getLevel();
  const w = getWorld();
  const wrap = document.getElementById('canvasWrap');
  let cw, ch;
  const eType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eType==='arch') {
    cw = l.canvasW; ch = l.canvasH;
  } else {
    const pad = eType==='circuit' ? 120 : 80;
    cw = l.gridW * l.cellSize + pad;
    ch = l.gridH * l.cellSize + pad;
  }
  const aspect = cw/ch;
  const maxW = wrap.clientWidth;
  const maxH = wrap.clientHeight || 500;
  let rw, rh;
  if (maxW/maxH > aspect) { rh=maxH; rw=rh*aspect; } else { rw=maxW; rh=rw/aspect; }
  canvas.width = cw; canvas.height = ch;
  canvas.style.width = rw+'px'; canvas.style.height = rh+'px';
}

// â”€â”€ MATERIAL BUTTONS â”€â”€
function updateMaterialBtns() {
  const w = getWorld();
  const container = document.getElementById('matBtns');
  container.innerHTML = '';
  const l = getLevel();
  const eType = (w.testType==='castle') ? (l ? l.castlePhase : w.testType) : w.testType;
  if (eType==='arch' && archState) {
    // Show material selector for arch stones
    for (const [key, mat] of Object.entries(w.materials)) {
      const btn = document.createElement('button');
      btn.className = 'mat-btn' + (archState.material===key?' active':'');
      btn.innerHTML = `${mat.emoji} ${mat.name}`;
      btn.onclick = () => { archState.material=key; updateMaterialBtns(); };
      container.appendChild(btn);
    }
    return;
  }
  for (const [key, mat] of Object.entries(w.materials)) {
    const btn = document.createElement('button');
    btn.className = 'mat-btn' + (material===key?' active':'');
    btn.innerHTML = `${mat.emoji} ${mat.name}`;
    btn.onclick = () => { material=key; updateMaterialBtns(); };
    container.appendChild(btn);
  }
}

function updateGameUI() {
  const l = getLevel();
  document.getElementById('gameTitle').textContent = l.name;
  const w = getWorld();
  const eType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eType==='arch' && archState) {
    updateArchUI();
  } else {
    const beamWord = eType==='circuit' ? 'Wires' : 'Beams';
    let meta = `${beamWord}: ${gameBeams.length} | Par: ${l.par}`;
    if (l.budget) {
      const spent = gameBeams.reduce((s,b) => s + ((getWorld().materials[b.material]||{}).cost||1), 0);
      meta += ` | ğŸ’° ${l.budget - spent}/${l.budget}`;
    }
    document.getElementById('gameMeta').textContent = meta;
    document.getElementById('testBtn').disabled = gameBeams.length === 0;
  }
}

function toggleHelp() {
  helpVisible = !helpVisible;
  document.getElementById('helpOverlay').style.display = helpVisible ? 'flex' : 'none';
}
function clearBeams() {
  if (archState) {
    archState.placed.clear();
    if (archState.placed2) archState.placed2.clear();
    archState.testPhase=null;
    updateArchUI(); drawGame(); return;
  }
  gameBeams=[]; selectedNode=null; updateGameUI(); drawGame();
}
function exitGame() {
  isTesting=false; failurePhase=null;
  if (animId) cancelAnimationFrame(animId);
  vehicle=null; weightObj=null; buddy.stop();
  window._isDailyChallenge = false; window._dailyLevel = null;
  h2hState = null; coopState = null; archState = null; flightState = null; hidePlayerBanner();
  showScreen('levels');
}

// â”€â”€ CANVAS INPUT (unified drag/tap/rotate system) â”€â”€
let dragState = null; // { type:'arch'|'beam'|'node', idx, startPt, originShapes, moved }

(function() {
  let lastTap = 0;
  document.addEventListener('DOMContentLoaded', () => {
    const c = document.getElementById('gameCanvas');

    c.addEventListener('pointerdown', (e) => {
      if (isTesting || failurePhase) return;
      e.preventDefault();
      const pt = canvasPoint(e);
      if (!pt) return;
      dragState = null;

      // â”€â”€ ARCH MODE: check if tapping a placed stone (to drag) or empty slot (to place) â”€â”€
      if (archState && !archState.testPhase) {
        // Try to grab an already-placed stone for dragging
        const grabPlaced = (shapes, placed, prePlaced, keystoneIdx) => {
          const hit = archHitTest(pt, shapes, placed, false); // find placed stone
          if (hit >= 0 && !(prePlaced && prePlaced.has(hit))) {
            return hit;
          }
          return -1;
        };
        let grabbed = grabPlaced(archState.shapes, archState.placed, archState.prePlaced, archState.keystoneIdx);
        if (grabbed >= 0) {
          dragState = { type:'arch', idx:grabbed, archSet:1, startPt:{...pt}, moved:false, startTime:Date.now() };
          return;
        }
        if (getLevel().archType==='double' && archState.shapes2) {
          grabbed = grabPlaced(archState.shapes2, archState.placed2, archState.prePlaced2, archState.keystoneIdx2);
          if (grabbed >= 0) {
            dragState = { type:'arch', idx:grabbed, archSet:2, startPt:{...pt}, moved:false, startTime:Date.now() };
            return;
          }
        }
        // Not grabbing a placed stone â€” try placing in empty slot
        const now = Date.now();
        if (now - lastTap < 350) { handleArchRemove(pt); lastTap=0; return; }
        lastTap = now;
        handleArchTap(pt);
        return;
      }

      // â”€â”€ NODE CHECK FIRST: always prioritize node taps over beam drags â”€â”€
      const now = Date.now();
      if (now - lastTap < 350) { removeBeamAt(pt); lastTap=0; return; }
      lastTap = now;

      let closest=null, closestDist=35;
      for (const n of gameNodes) {
        const d = Math.hypot(n.x-pt.x, n.y-pt.y);
        if (d<closestDist) { closestDist=d; closest=n; }
      }

      // If tap is near a node, handle node selection/connection (beam creation)
      if (closest) {
        // Clear beam selection when working with nodes
        selectedBeamIdx=-1; showRotateBtn(false);
        if (!selectedNode) { selectedNode=closest; }
        else if (closest===selectedNode) { selectedNode=null; }
        else {
          const exists = gameBeams.some(b=>!b.broken&&((b.a===selectedNode&&b.b===closest)||(b.a===closest&&b.b===selectedNode)));
          if (!exists) {
            const gdx=Math.abs(closest.gx-selectedNode.gx), gdy=Math.abs(closest.gy-selectedNode.gy);
            if (gdx<=2 && gdy<=2 && !(gdx===0&&gdy===0)) {
              const lvl = getLevel();
              if (lvl.budget) {
                const cost = (getWorld().materials[material]||{}).cost||1;
                const spent = gameBeams.reduce((s,b) => s + ((getWorld().materials[b.material]||{}).cost||1), 0);
                if (spent + cost > lvl.budget) { selectedNode=null; updateGameUI(); drawGame(); return; }
              }
              const dx=closest.x-selectedNode.x, dy=closest.y-selectedNode.y;
              gameBeams.push({ a:selectedNode, b:closest, material, restLength:Math.sqrt(dx*dx+dy*dy), stress:0, broken:false });
              sfx.play('place');
              if (coopState) coopAfterBeamPlaced();
            }
          }
          selectedNode=null;
        }
        updateGameUI(); drawGame();
        return;
      }

      // â”€â”€ No node nearby: check if grabbing an existing beam to drag it â”€â”€
      const beamHit = findBeamAt(pt);
      if (beamHit >= 0) {
        dragState = { type:'beam', idx:beamHit, startPt:{...pt}, moved:false, startTime:Date.now(),
          origA:{x:gameBeams[beamHit].a.x, y:gameBeams[beamHit].a.y, gx:gameBeams[beamHit].a.gx, gy:gameBeams[beamHit].a.gy},
          origB:{x:gameBeams[beamHit].b.x, y:gameBeams[beamHit].b.y, gx:gameBeams[beamHit].b.gx, gy:gameBeams[beamHit].b.gy}
        };
        return;
      }

      // Nothing hit â€” deselect everything
      selectedNode=null; selectedBeamIdx=-1; showRotateBtn(false);
      updateGameUI(); drawGame();
    });

    // â”€â”€ POINTER MOVE: handle dragging â”€â”€
    c.addEventListener('pointermove', (e) => {
      if (!dragState || isTesting || failurePhase) return;
      e.preventDefault();
      const pt = canvasPoint(e);
      if (!pt) return;
      const dx = pt.x - dragState.startPt.x;
      const dy = pt.y - dragState.startPt.y;
      if (Math.hypot(dx,dy) > 8) dragState.moved = true;
      if (!dragState.moved) return;

      if (dragState.type === 'arch') {
        // Show drag ghost â€” highlight nearest empty slot
        const shapes = dragState.archSet===1 ? archState.shapes : archState.shapes2;
        const placed = dragState.archSet===1 ? archState.placed : archState.placed2;
        dragState.dragPt = pt;
        dragState.nearestEmpty = -1;
        let bestD = 60;
        for (let i=0; i<shapes.length; i++) {
          if (placed.has(i) && i !== dragState.idx) continue; // skip other placed stones
          if (i === dragState.idx) continue; // skip self
          const d = Math.hypot(pt.x - shapes[i].cx, pt.y - shapes[i].cy);
          if (d < bestD) { bestD = d; dragState.nearestEmpty = i; }
        }
        drawGame();
      } else if (dragState.type === 'beam') {
        // Move beam: find new pair of nodes closest to beam's shifted position
        dragState.dragPt = pt;
        drawGame();
      }
    });

    // â”€â”€ POINTER UP: finalize drag or treat as tap â”€â”€
    c.addEventListener('pointerup', (e) => {
      if (!dragState) return;
      const pt = canvasPoint(e);

      if (dragState.type === 'arch' && dragState.moved) {
        // Finalize arch stone drag: move stone from old slot to nearest empty slot
        const placed = dragState.archSet===1 ? archState.placed : archState.placed2;
        const prePlaced = dragState.archSet===1 ? archState.prePlaced : archState.prePlaced2;
        if (dragState.nearestEmpty >= 0 && !(prePlaced && prePlaced.has(dragState.nearestEmpty))) {
          placed.delete(dragState.idx);
          placed.add(dragState.nearestEmpty);
          sfx.play('place');
          updateArchUI();
        }
      } else if (dragState.type === 'beam' && dragState.moved && pt) {
        // Finalize beam drag: snap to new node pair
        const dx = pt.x - dragState.startPt.x;
        const dy = pt.y - dragState.startPt.y;
        const beam = gameBeams[dragState.idx];
        // Find closest node to shifted A position
        const newAx = dragState.origA.x + dx, newAy = dragState.origA.y + dy;
        const newBx = dragState.origB.x + dx, newBy = dragState.origB.y + dy;
        let bestA=null, bestAdist=50;
        let bestB=null, bestBdist=50;
        for (const n of gameNodes) {
          const dA = Math.hypot(n.x-newAx, n.y-newAy);
          const dB = Math.hypot(n.x-newBx, n.y-newBy);
          if (dA < bestAdist) { bestAdist=dA; bestA=n; }
          if (dB < bestBdist) { bestBdist=dB; bestB=n; }
        }
        if (bestA && bestB && bestA !== bestB) {
          const gdx2 = Math.abs(bestA.gx-bestB.gx), gdy2 = Math.abs(bestA.gy-bestB.gy);
          if (gdx2<=2 && gdy2<=2 && !(gdx2===0&&gdy2===0)) {
            const exists = gameBeams.some((b,i)=>i!==dragState.idx&&!b.broken&&((b.a===bestA&&b.b===bestB)||(b.a===bestB&&b.b===bestA)));
            if (!exists) {
              beam.a = bestA; beam.b = bestB;
              const bDx = bestB.x-bestA.x, bDy = bestB.y-bestA.y;
              beam.restLength = Math.sqrt(bDx*bDx+bDy*bDy);
              sfx.play('place');
            }
          }
        }
        updateGameUI();
      }
      // If beam was tapped (not dragged), select it for rotation
      if (dragState && dragState.type==='beam' && !dragState.moved) {
        selectedBeamIdx = dragState.idx;
        showRotateBtn(true);
        selectedNode = null; // deselect any node
      } else {
        selectedBeamIdx = -1;
        showRotateBtn(false);
      }
      dragState = null;
      drawGame();
    });

    c.addEventListener('pointercancel', () => { dragState = null; drawGame(); });
  });
})();

// Find beam at point (for drag-grabbing)
function findBeamAt(pt) {
  for (let i=gameBeams.length-1; i>=0; i--) {
    const b = gameBeams[i];
    if (b.broken) continue;
    // Distance from point to line segment
    const dx = b.b.x-b.a.x, dy = b.b.y-b.a.y;
    const len2 = dx*dx+dy*dy;
    if (len2 === 0) continue;
    let t = ((pt.x-b.a.x)*dx + (pt.y-b.a.y)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const px = b.a.x + t*dx, py = b.a.y + t*dy;
    const dist = Math.hypot(pt.x-px, pt.y-py);
    if (dist < 18) return i;
  }
  return -1;
}

// Rotate a selected beam 45Â° around its midpoint, snapping endpoints to nearest grid nodes
let selectedBeamIdx = -1;

function rotateSelected() {
  if (selectedBeamIdx < 0 || selectedBeamIdx >= gameBeams.length) return;
  const beam = gameBeams[selectedBeamIdx];
  const midX = (beam.a.x + beam.b.x)/2;
  const midY = (beam.a.y + beam.b.y)/2;
  const dx = beam.b.x - beam.a.x;
  const dy = beam.b.y - beam.a.y;
  // Rotate 45 degrees
  const cos45 = Math.cos(Math.PI/4), sin45 = Math.sin(Math.PI/4);
  const newDx = dx*cos45 - dy*sin45;
  const newDy = dx*sin45 + dy*cos45;
  // Find nearest grid nodes to new endpoints
  const newAx = midX - newDx/2, newAy = midY - newDy/2;
  const newBx = midX + newDx/2, newBy = midY + newDy/2;
  let bestA=null, bestAdist=60, bestB=null, bestBdist=60;
  for (const n of gameNodes) {
    const dA = Math.hypot(n.x-newAx, n.y-newAy);
    const dB = Math.hypot(n.x-newBx, n.y-newBy);
    if (dA<bestAdist) { bestAdist=dA; bestA=n; }
    if (dB<bestBdist) { bestBdist=dB; bestB=n; }
  }
  if (bestA && bestB && bestA !== bestB) {
    const gdx = Math.abs(bestA.gx-bestB.gx), gdy = Math.abs(bestA.gy-bestB.gy);
    if (gdx<=2 && gdy<=2 && !(gdx===0&&gdy===0)) {
      const exists = gameBeams.some((b,i) => i!==selectedBeamIdx && !b.broken &&
        ((b.a===bestA&&b.b===bestB)||(b.a===bestB&&b.b===bestA)));
      if (!exists) {
        beam.a = bestA; beam.b = bestB;
        const bDx = bestB.x-bestA.x, bDy = bestB.y-bestA.y;
        beam.restLength = Math.sqrt(bDx*bDx+bDy*bDy);
        sfx.play('place');
        updateGameUI(); drawGame();
        return;
      }
    }
  }
  // Couldn't snap â€” try a different rotation (90Â°)
  const cos90 = 0, sin90 = 1;
  const newDx2 = dx*cos90 - dy*sin90;
  const newDy2 = dx*sin90 + dy*cos90;
  const newAx2 = midX - newDx2/2, newAy2 = midY - newDy2/2;
  const newBx2 = midX + newDx2/2, newBy2 = midY + newDy2/2;
  bestA=null; bestAdist=60; bestB=null; bestBdist=60;
  for (const n of gameNodes) {
    const dA = Math.hypot(n.x-newAx2, n.y-newAy2);
    const dB = Math.hypot(n.x-newBx2, n.y-newBy2);
    if (dA<bestAdist) { bestAdist=dA; bestA=n; }
    if (dB<bestBdist) { bestBdist=dB; bestB=n; }
  }
  if (bestA && bestB && bestA !== bestB) {
    const gdx = Math.abs(bestA.gx-bestB.gx), gdy = Math.abs(bestA.gy-bestB.gy);
    if (gdx<=2 && gdy<=2 && !(gdx===0&&gdy===0)) {
      const exists = gameBeams.some((b,i) => i!==selectedBeamIdx && !b.broken &&
        ((b.a===bestA&&b.b===bestB)||(b.a===bestB&&b.b===bestA)));
      if (!exists) {
        beam.a = bestA; beam.b = bestB;
        const bDx = bestB.x-bestA.x, bDy = bestB.y-bestA.y;
        beam.restLength = Math.sqrt(bDx*bDx+bDy*bDy);
        sfx.play('place');
        updateGameUI(); drawGame();
      }
    }
  }
}

function showRotateBtn(show) {
  document.getElementById('rotateBtn').style.display = show ? 'inline-block' : 'none';
}

function canvasPoint(e) {
  if (!canvas) return null;
  const r=canvas.getBoundingClientRect();
  return { x:(e.clientX-r.left)*(canvas.width/r.width), y:(e.clientY-r.top)*(canvas.height/r.height) };
}

function removeBeamAt(pt) {
  let ci=-1, cd=25;
  gameBeams.forEach((b,i) => {
    if (b.broken) return;
    const dx=b.b.x-b.a.x, dy=b.b.y-b.a.y;
    const l2=dx*dx+dy*dy;
    let t=l2===0?0:((pt.x-b.a.x)*dx+(pt.y-b.a.y)*dy)/l2;
    t=Math.max(0,Math.min(1,t));
    const d=Math.hypot(pt.x-(b.a.x+t*dx), pt.y-(b.a.y+t*dy));
    if (d<cd) { cd=d; ci=i; }
  });
  if (ci>=0) { gameBeams.splice(ci,1); sfx.play('remove'); updateGameUI(); drawGame(); }
}

// â”€â”€ DRAWING â”€â”€
function drawGame() {
  if (!ctx) return;
  const w = getWorld();
  const l = getLevel();
  const eType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eType==='circuit') drawCircuitWorld();
  else if (eType==='arch' || (archState && !archState.testPhase)) drawCastleArchWorld();
  else if (w.id==='flying') drawFlyingWorld();
  else if (w.id==='towers') drawTowerWorld();
  else if (w.id==='castle') drawCastleWorld();
  else if (w.id==='arches') drawCastleArchWorld();
  else drawBridgeWorld();
}

function drawCastleArchWorld() { drawArchWorld(); }

function drawCastleWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Night sky gradient for castle atmosphere
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#1a1a2e'); sg.addColorStop(0.4,'#16213e'); sg.addColorStop(0.7,'#2c3e50'); sg.addColorStop(1,'#4a6741');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  // Stars
  ctx.fillStyle='#fff';
  for (let i=0;i<30;i++) {
    const sx=(Math.sin(i*127.1+42)*0.5+0.5)*W;
    const sy=(Math.sin(i*311.7+13)*0.5+0.5)*H*0.4;
    const sr=Math.random()*1.5+0.5;
    ctx.globalAlpha=0.3+Math.random()*0.5;
    ctx.beginPath(); ctx.arc(sx,sy,sr,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1;
  // Moon
  ctx.fillStyle='#f5f5dc'; ctx.beginPath(); ctx.arc(W-60,50,25,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#1a1a2e'; ctx.beginPath(); ctx.arc(W-50,45,22,0,Math.PI*2); ctx.fill();
  // Ground with stone wall texture
  drawGround(l);
  // Castle wall outlines on ground
  const groundY = 40 + (l.gridH-1)*l.cellSize;
  ctx.fillStyle='rgba(139,119,101,0.3)';
  ctx.fillRect(0,groundY,W,H-groundY);
  // Crenellations
  ctx.fillStyle='rgba(139,119,101,0.2)';
  for (let x=0;x<W;x+=20) {
    if (Math.floor(x/20)%2===0) ctx.fillRect(x,groundY-10,18,10);
  }
  // Building silhouette if applicable
  if (l.buildingShape) drawBuildingSilhouette(l);
  // Target line
  if (l.targetRow !== undefined) {
    const ty = 40 + l.targetRow * l.cellSize;
    ctx.setLineDash([8,6]);
    ctx.strokeStyle='#FFD700'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(20,ty); ctx.lineTo(W-20,ty); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#FFD700'; ctx.font='bold 13px sans-serif'; ctx.textAlign='right';
    ctx.fillText('TARGET â–¸',W-25,ty-6);
  }
  // Budget display
  if (l.budget) {
    const spent = gameBeams.reduce((s,b) => s + ((getWorld().materials[b.material]||{}).cost||1), 0);
    const remaining = l.budget - spent;
    ctx.fillStyle = remaining > 10 ? 'rgba(76,175,80,0.9)' : remaining > 5 ? 'rgba(255,193,7,0.95)' : 'rgba(244,67,54,0.95)';
    ctx.font='bold 14px sans-serif'; ctx.textAlign='left';
    ctx.fillText(`ğŸ’° Budget: ${remaining}/${l.budget}`,12,20);
  }
  drawBeamsAndNodes();
  if (weightObj && weightObj.active) drawWeight();
  // Wind indicator â€” show before AND during test
  if (l.windForce) {
    const alpha = isTesting ? 0.45 : 0.15;
    ctx.fillStyle=`rgba(100,181,246,${alpha})`;
    ctx.font='bold 24px sans-serif'; ctx.textAlign='center';
    const windX = 30, windY = H/2;
    for (let i=0;i<3;i++) ctx.fillText('â†’',windX,windY-30+i*30);
    ctx.font='bold 11px sans-serif';
    ctx.fillText(isTesting?'WIND!':'âš ï¸ WIND',windX+5,windY+50);
  }
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawFlyingWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Sky gradient (high altitude blue)
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#0D47A1'); sg.addColorStop(0.3,'#1976D2'); sg.addColorStop(0.6,'#42A5F5'); sg.addColorStop(1,'#90CAF9');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  // Clouds moving past
  const t = Date.now()*0.001;
  ctx.fillStyle='rgba(255,255,255,0.15)';
  for (let i=0;i<8;i++) {
    const cx = ((t*30*(0.5+i*0.2) + i*137) % (W+100)) - 50;
    const cy = 30 + (i%3)*H/4 + Math.sin(i*2.7)*30;
    ctx.beginPath(); ctx.ellipse(cx,cy,40+i*5,15+i*2,0,0,Math.PI*2); ctx.fill();
  }
  // Wind arrows showing airflow direction
  ctx.save();
  ctx.globalAlpha = 0.2;
  ctx.strokeStyle='#fff'; ctx.lineWidth=1.5;
  for (let i=0;i<6;i++) {
    const ax = ((t*60 + i*80) % (W+40)) - 20;
    const ay = 40 + i*(H-80)/5;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(ax+30,ay);
    ctx.moveTo(ax+25,ay-5); ctx.lineTo(ax+30,ay); ctx.lineTo(ax+25,ay+5);
    ctx.stroke();
  }
  ctx.restore();
  // Flight altitude meter
  ctx.fillStyle='rgba(0,0,0,0.4)';
  roundRect(ctx,W-45,30,30,H-60,8); ctx.fill();
  ctx.fillStyle='rgba(76,175,80,0.6)';
  const targetPct = Math.min(1, (flightState ? flightState.altitude : 0) / l.flightTarget);
  const meterH = (H-70)*targetPct;
  ctx.fillRect(W-42,H-33-meterH,24,meterH);
  // Target line on meter
  ctx.strokeStyle='#FFD700'; ctx.lineWidth=2; ctx.setLineDash([4,3]);
  const targetY = H-33-(H-70);
  ctx.beginPath(); ctx.moveTo(W-45,targetY); ctx.lineTo(W-12,targetY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='#FFD700'; ctx.font='bold 10px sans-serif'; ctx.textAlign='right';
  ctx.fillText(`${l.flightTarget}ft`,W-48,targetY+4);
  // Flight info panel
  ctx.fillStyle='rgba(0,0,0,0.5)';
  roundRect(ctx,8,8,160,68,8); ctx.fill();
  ctx.fillStyle='#fff'; ctx.font='bold 12px sans-serif'; ctx.textAlign='left';
  const lift = flightState ? flightState.lift.toFixed(1) : '0.0';
  const drag = flightState ? flightState.drag.toFixed(1) : '0.0';
  const wt = flightState ? flightState.weight.toFixed(1) : '0.0';
  ctx.fillStyle='#4CAF50'; ctx.fillText(`â†‘ Lift: ${lift}`,16,26);
  ctx.fillStyle='#F44336'; ctx.fillText(`â† Drag: ${drag}`,16,42);
  ctx.fillStyle='#FFC107'; ctx.fillText(`â†“ Weight: ${wt}`,16,58);
  // Draw beams and nodes
  drawBeamsAndNodes();
  // Flying aircraft animation during test
  if (flightState && flightState.active) {
    const pulse = 0.5+0.5*Math.sin(Date.now()*0.005);
    ctx.fillStyle=`rgba(76,175,80,${0.2+pulse*0.2})`;
    ctx.beginPath(); ctx.arc(W/2,H/2-flightState.altitude*0.3,60,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='bold 16px sans-serif'; ctx.textAlign='center';
    ctx.fillText(`${Math.floor(flightState.altitude)} ft`,W/2,H/2-flightState.altitude*0.3-10);
  }
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawBridgeWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Sky
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#87CEEB'); sg.addColorStop(1,'#E0F4FF');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  // Clouds
  drawClouds(W);
  // Water
  drawWater(l);
  // Ground
  drawGround(l);
  // Beams & Nodes
  drawBeamsAndNodes();
  // Vehicle
  if (vehicle && vehicle.active) drawVehicle();
  // Weight for arches
  if (weightObj && weightObj.active) drawWeight();
  // Failure highlights
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawTowerWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Sky gradient
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#5C6BC0'); sg.addColorStop(0.5,'#9FA8DA'); sg.addColorStop(1,'#C5CAE9');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  drawClouds(W);
  // Ground
  drawGround(l);
  // Draw building silhouette hint
  if (l.buildingShape) drawBuildingSilhouette(l);
  // Target line
  if (l.targetRow !== undefined) {
    const ty = 40 + l.targetRow * l.cellSize;
    ctx.setLineDash([8,6]);
    ctx.strokeStyle='#F44336'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(20,ty); ctx.lineTo(W-20,ty); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#F44336'; ctx.font='bold 13px sans-serif'; ctx.textAlign='right';
    ctx.fillText('TARGET â–¸',W-25,ty-6);
  }
  // Budget display
  if (l.budget) {
    const spent = gameBeams.reduce((s,b) => s + ((getWorld().materials[b.material]||{}).cost||1), 0);
    const remaining = l.budget - spent;
    ctx.fillStyle = remaining > 10 ? 'rgba(76,175,80,0.8)' : remaining > 5 ? 'rgba(255,193,7,0.9)' : 'rgba(244,67,54,0.9)';
    ctx.font='bold 14px sans-serif'; ctx.textAlign='left';
    ctx.fillText(`ğŸ’° Budget: ${remaining}/${l.budget}`,12,20);
  }
  drawBeamsAndNodes();
  if (weightObj && weightObj.active) drawWeight();
  // Wind indicator â€” show before AND during test
  if (l.windForce) {
    const alpha = isTesting ? 0.4 : 0.15;
    ctx.fillStyle=`rgba(100,181,246,${alpha})`;
    ctx.font='bold 24px sans-serif'; ctx.textAlign='center';
    const windX = 30, windY = H/2;
    for (let i=0;i<3;i++) ctx.fillText('â†’',windX,windY-30+i*30);
    ctx.font='bold 11px sans-serif';
    ctx.fillText(isTesting?'WIND!':'âš ï¸ WIND',windX+5,windY+50);
  }
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawBuildingSilhouette(l) {
  const cs=l.cellSize, ox=40, oy=40;
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = '#3F51B5';
  ctx.strokeStyle = 'rgba(63,81,181,0.15)';
  ctx.lineWidth = 2;
  const gw=l.gridW, gh=l.gridH;
  const bx = ox + cs*(gw-1)/2; // center x
  const groundY = oy + (gh-2)*cs;
  const topY = oy + l.targetRow*cs;
  if (l.buildingShape === 'pyramid') {
    ctx.beginPath();
    ctx.moveTo(bx, topY);
    ctx.lineTo(ox - cs/2, groundY);
    ctx.lineTo(ox + (gw-1)*cs + cs/2, groundY);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
  } else if (l.buildingShape === 'eiffel') {
    const w1 = cs*0.5, w2 = cs*2, w3 = cs*(gw/2);
    const h = groundY - topY;
    ctx.beginPath();
    ctx.moveTo(bx - w1, topY);
    ctx.lineTo(bx + w1, topY);
    ctx.quadraticCurveTo(bx + w2, topY + h*0.5, bx + w3, groundY);
    ctx.lineTo(bx - w3, groundY);
    ctx.quadraticCurveTo(bx - w2, topY + h*0.5, bx - w1, topY);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
  } else if (l.buildingShape === 'taipei') {
    // Taipei 101: stacked sections that step inward going up (like bamboo segments)
    const sections = 8;
    const h = groundY - topY;
    const secH = h / sections;
    for (let i=0; i<sections; i++) {
      // Width tapers as we go UP (i=0 is top, i=7 is bottom)
      const w = cs*(0.6 + (sections-i)*0.22);
      const y1 = topY + i*secH;
      ctx.beginPath();
      ctx.rect(bx-w, y1, w*2, secH-3);
      ctx.fill(); ctx.stroke();
    }
    // Spire at top
    ctx.beginPath(); ctx.moveTo(bx, topY-cs*0.8); ctx.lineTo(bx-cs*0.15, topY); ctx.lineTo(bx+cs*0.15, topY); ctx.closePath();
    ctx.fill(); ctx.stroke();
  } else if (l.buildingShape === 'burj') {
    // Burj Khalifa: Y-shaped core tapering to a needle at top, widening at base
    const h = groundY - topY;
    ctx.beginPath();
    // Spire
    ctx.moveTo(bx, topY - cs*0.5);
    ctx.lineTo(bx, topY);
    // Left side: narrow at top, widens with stepped setbacks
    ctx.lineTo(bx - cs*0.4, topY + h*0.1);
    ctx.lineTo(bx - cs*0.7, topY + h*0.25);
    ctx.lineTo(bx - cs*1.0, topY + h*0.45);
    ctx.lineTo(bx - cs*1.5, topY + h*0.65);
    ctx.lineTo(bx - cs*2.2, topY + h*0.85);
    ctx.lineTo(bx - cs*2.5, groundY);
    // Base
    ctx.lineTo(bx + cs*2.5, groundY);
    // Right side: mirror
    ctx.lineTo(bx + cs*2.2, topY + h*0.85);
    ctx.lineTo(bx + cs*1.5, topY + h*0.65);
    ctx.lineTo(bx + cs*1.0, topY + h*0.45);
    ctx.lineTo(bx + cs*0.7, topY + h*0.25);
    ctx.lineTo(bx + cs*0.4, topY + h*0.1);
    ctx.lineTo(bx, topY);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawCircuitWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  const w = getWorld();
  // Dark background
  ctx.fillStyle='#0d1117'; ctx.fillRect(0,0,W,H);
  // Grid lines
  ctx.strokeStyle='rgba(48,54,61,0.6)'; ctx.lineWidth=1;
  for (let x=60;x<W;x+=l.cellSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y=60;y<H;y+=l.cellSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  // Blocked cells
  if (l.blocked) {
    for (const [bx,by] of l.blocked) {
      const cx=60+bx*l.cellSize, cy=60+by*l.cellSize;
      ctx.fillStyle='rgba(244,67,54,0.15)';
      ctx.fillRect(cx-l.cellSize/2+2,cy-l.cellSize/2+2,l.cellSize-4,l.cellSize-4);
      ctx.strokeStyle='rgba(244,67,54,0.4)'; ctx.lineWidth=2;
      ctx.strokeRect(cx-l.cellSize/2+2,cy-l.cellSize/2+2,l.cellSize-4,l.cellSize-4);
      ctx.strokeStyle='#F44336'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cx-8,cy-8); ctx.lineTo(cx+8,cy+8); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx+8,cy-8); ctx.lineTo(cx-8,cy+8); ctx.stroke();
    }
  }
  // Wires (beams)
  const drawB = isTesting ? physicsBeams : gameBeams;
  for (const beam of drawB) {
    if (beam.broken) continue;
    const mat = w.materials[beam.material];
    const powered = isTesting && circuitReached.has(beam.a) && circuitReached.has(beam.b);
    // Glow
    if (powered) {
      ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
      ctx.strokeStyle = beam.material==='copper' ? 'rgba(255,152,0,0.3)' : 'rgba(0,188,212,0.3)';
      ctx.lineWidth = mat.width+8; ctx.lineCap='round'; ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = powered ? (beam.material==='copper'?'#FFB74D':'#4DD0E1') : mat.color;
    ctx.lineWidth = mat.width; ctx.lineCap='round'; ctx.stroke();
  }
  // Particles
  if (isTesting) {
    for (const p of circuitParticles) {
      ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2);
      ctx.fillStyle='#FFEB3B'; ctx.fill();
      ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2);
      ctx.fillStyle='rgba(255,235,59,0.2)'; ctx.fill();
    }
  }
  // Nodes
  const drawN = isTesting ? physicsNodes : gameNodes;
  for (const n of drawN) {
    const powered = isTesting && circuitReached.has(n);
    if (n.nodeType==='source') {
      ctx.beginPath(); ctx.arc(n.x,n.y,16,0,Math.PI*2);
      ctx.fillStyle=powered?'#FFD600':'#FFC107'; ctx.fill();
      ctx.strokeStyle='#FF8F00'; ctx.lineWidth=3; ctx.stroke();
      ctx.fillStyle='#000'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('ğŸ”‹',n.x,n.y);
    } else if (n.nodeType==='target') {
      ctx.beginPath(); ctx.arc(n.x,n.y,16,0,Math.PI*2);
      ctx.fillStyle=powered?'#FFEB3B':'#263238'; ctx.fill();
      ctx.strokeStyle=powered?'#FFD600':'#00BCD4'; ctx.lineWidth=3; ctx.stroke();
      ctx.fillStyle=powered?'#000':'#fff'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(powered?'ğŸ’¡':'ğŸ’¡',n.x,n.y);
      if (powered) {
        ctx.beginPath(); ctx.arc(n.x,n.y,22,0,Math.PI*2);
        ctx.fillStyle='rgba(255,235,59,0.15)'; ctx.fill();
      }
    } else {
      ctx.beginPath(); ctx.arc(n.x,n.y,5,0,Math.PI*2);
      ctx.fillStyle = powered?'#4CAF50':'#455A64'; ctx.fill();
    }
    if (selectedNode===n && !isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,20,0,Math.PI*2);
      ctx.strokeStyle='#FF9800'; ctx.lineWidth=3;
      ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
    }
  }
}

// â”€â”€ SHARED DRAW HELPERS â”€â”€
function drawClouds(W) {
  ctx.fillStyle='rgba(255,255,255,0.5)';
  const t=Date.now()*0.00008;
  for (let i=0;i<5;i++) {
    const cx=((i*180+t*60*(i+1))%(W+120))-60;
    const cy=15+i*22;
    ctx.beginPath(); ctx.arc(cx,cy,22,0,Math.PI*2); ctx.arc(cx+18,cy-7,17,0,Math.PI*2); ctx.arc(cx+36,cy,20,0,Math.PI*2); ctx.fill();
  }
}

function drawWater(l) {
  if (!l.waterTiles) return;
  for (const [gx,gy] of l.waterTiles) {
    const wx=40+gx*l.cellSize-l.cellSize/2, wy=40+gy*l.cellSize-l.cellSize/2;
    const wg=ctx.createLinearGradient(wx,wy,wx,wy+l.cellSize);
    wg.addColorStop(0,'#29B6F6'); wg.addColorStop(1,'#0288D1');
    ctx.fillStyle=wg; ctx.fillRect(wx,wy,l.cellSize,l.cellSize);
    ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5;
    const wt=Date.now()*0.003;
    ctx.beginPath();
    for (let px=wx;px<wx+l.cellSize;px+=3) ctx.lineTo(px,wy+8+Math.sin(wt+px*0.08)*3);
    ctx.stroke();
  }
}

function drawGround(l) {
  for (const [gx,gy] of l.groundTiles) {
    const tx=40+gx*l.cellSize-l.cellSize/2, ty=40+gy*l.cellSize-l.cellSize/2;
    ctx.fillStyle='#4CAF50'; ctx.fillRect(tx,ty,l.cellSize,l.cellSize);
    ctx.fillStyle='#66BB6A';
    for (let g=0;g<3;g++) {
      const gxp=tx+8+g*18;
      ctx.beginPath(); ctx.moveTo(gxp,ty); ctx.lineTo(gxp+3,ty-5); ctx.lineTo(gxp+6,ty); ctx.fill();
    }
  }
}

function drawBeamsAndNodes() {
  const w = getWorld();
  const drawB = isTesting ? physicsBeams : gameBeams;
  for (const beam of drawB) {
    if (beam.broken) {
      ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y);
      const mx=(beam.a.x+beam.b.x)/2, my=(beam.a.y+beam.b.y)/2;
      ctx.lineTo(mx+(Math.random()*10-5),my+Math.random()*10);
      ctx.strokeStyle='rgba(200,100,100,0.4)'; ctx.lineWidth=3; ctx.stroke();
      continue;
    }
    const mat = w.materials[beam.material];
    const breakAt=mat.maxStress*BREAK_MULT; const sc = beam.stress<breakAt*0.4?'#4CAF50':beam.stress<breakAt*0.75?'#FFC107':'#F44336';
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = isTesting?'rgba(0,0,0,0.15)':mat.stroke;
    ctx.lineWidth=mat.width+3; ctx.lineCap='round'; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = isTesting?sc:mat.color;
    ctx.lineWidth=mat.width; ctx.lineCap='round'; ctx.stroke();
  }
  const drawN = isTesting ? physicsNodes : gameNodes;
  for (const n of drawN) {
    if (n.fixed) {
      ctx.beginPath(); ctx.arc(n.x,n.y,13,0,Math.PI*2);
      ctx.strokeStyle='#FFD54F'; ctx.lineWidth=2; ctx.stroke();
      ctx.beginPath(); ctx.arc(n.x,n.y,9,0,Math.PI*2);
      ctx.fillStyle='#FF6F00'; ctx.fill();
      ctx.beginPath(); ctx.arc(n.x,n.y,4,0,Math.PI*2);
      ctx.fillStyle='#fff'; ctx.fill();
    } else if (!isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,5,0,Math.PI*2);
      ctx.fillStyle='#90A4AE'; ctx.fill();
    }
    if (selectedNode===n && !isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,18,0,Math.PI*2);
      ctx.strokeStyle='#FF9800'; ctx.lineWidth=3;
      ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
    }
  }
  // Highlight selected beam (for rotation)
  if (selectedBeamIdx >= 0 && selectedBeamIdx < gameBeams.length && !isTesting) {
    const sb = gameBeams[selectedBeamIdx];
    if (!sb.broken) {
      ctx.beginPath(); ctx.moveTo(sb.a.x,sb.a.y); ctx.lineTo(sb.b.x,sb.b.y);
      ctx.strokeStyle='rgba(255,152,0,0.4)'; ctx.lineWidth=16; ctx.lineCap='round'; ctx.stroke();
      // Rotation hint arrow
      const mx = (sb.a.x+sb.b.x)/2, my = (sb.a.y+sb.b.y)/2;
      ctx.fillStyle='#FF9800'; ctx.font='bold 16px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('ğŸ”„',mx,my-14);
    }
  }
  // Draw beam drag ghost
  if (dragState && dragState.type==='beam' && dragState.moved && dragState.dragPt) {
    const beam = gameBeams[dragState.idx];
    const dx = dragState.dragPt.x - dragState.startPt.x;
    const dy = dragState.dragPt.y - dragState.startPt.y;
    const ax = dragState.origA.x+dx, ay = dragState.origA.y+dy;
    const bx = dragState.origB.x+dx, by = dragState.origB.y+dy;
    // Ghost beam at dragged position
    ctx.globalAlpha = 0.4;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by);
    ctx.strokeStyle='#FF9800'; ctx.lineWidth=8; ctx.lineCap='round'; ctx.stroke();
    ctx.globalAlpha = 1;
    // Highlight original beam
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle='rgba(255,152,0,0.3)'; ctx.lineWidth=12; ctx.setLineDash([6,6]); ctx.stroke(); ctx.setLineDash([]);
    // Snap targets
    let bestA=null, bestAdist=50, bestB=null, bestBdist=50;
    for (const n of gameNodes) {
      const dA = Math.hypot(n.x-ax, n.y-ay), dB = Math.hypot(n.x-bx, n.y-by);
      if (dA<bestAdist) { bestAdist=dA; bestA=n; }
      if (dB<bestBdist) { bestBdist=dB; bestB=n; }
    }
    if (bestA) { ctx.beginPath(); ctx.arc(bestA.x,bestA.y,12,0,Math.PI*2); ctx.strokeStyle='#FF9800'; ctx.lineWidth=2; ctx.stroke(); }
    if (bestB) { ctx.beginPath(); ctx.arc(bestB.x,bestB.y,12,0,Math.PI*2); ctx.strokeStyle='#FF9800'; ctx.lineWidth=2; ctx.stroke(); }
  }
}

function drawVehicle() {
  const vx=vehicle.x, vy=vehicle.y-18;
  ctx.fillStyle='rgba(0,0,0,0.1)';
  ctx.beginPath(); ctx.ellipse(vx,vy+28,24,5,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#FF5722'; roundRect(ctx,vx-22,vy-14,44,22,5); ctx.fill();
  ctx.fillStyle='#E64A19'; roundRect(ctx,vx+4,vy-26,18,16,4); ctx.fill();
  ctx.fillStyle='#B3E5FC'; ctx.fillRect(vx+7,vy-23,12,9);
  ctx.fillStyle='#333';
  ctx.beginPath(); ctx.arc(vx-12,vy+8,7,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(vx+12,vy+8,7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#999';
  ctx.beginPath(); ctx.arc(vx-12,vy+8,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(vx+12,vy+8,3,0,Math.PI*2); ctx.fill();
}

function drawWeight() {
  const wx=weightObj.x, wy=weightObj.y;
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.beginPath(); ctx.ellipse(wx,wy+30,30,6,0,0,Math.PI*2); ctx.fill();
  // Block
  ctx.fillStyle='#5D4037'; roundRect(ctx,wx-25,wy-18,50,36,6); ctx.fill();
  ctx.fillStyle='#4E342E'; roundRect(ctx,wx-22,wy-15,44,30,4); ctx.fill();
  // Label
  ctx.fillStyle='#FFCC80'; ctx.font='bold 12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('HEAVY',wx,wy);
  // Chains
  ctx.strokeStyle='#9E9E9E'; ctx.lineWidth=2;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(wx-10,wy-18); ctx.lineTo(wx-10,wy-45); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(wx+10,wy-18); ctx.lineTo(wx+10,wy-45); ctx.stroke();
  ctx.setLineDash([]);
}

function drawFailureHighlights() {
  if (!failureData) return;
  const pulse = 0.5 + 0.5*Math.sin(Date.now()*0.008);
  // Color-code ALL beams by stress level
  if (physicsBeams) {
    for (const b of physicsBeams) {
      if (!b.a || !b.b) continue;
      const w = getWorld();
      const mat = w.materials[b.material] || Object.values(w.materials)[0];
      const stressRatio = b.stress / (mat.maxStress * BREAK_MULT);
      let color;
      if (b.broken) color = `rgba(244,67,54,${0.7+pulse*0.3})`;
      else if (stressRatio > 0.7) color = `rgba(255,193,7,${0.6+pulse*0.3})`;
      else color = `rgba(76,175,80,${0.4+pulse*0.2})`;
      ctx.beginPath();
      ctx.moveTo(b.a.x, b.a.y); ctx.lineTo(b.b.x, b.b.y);
      ctx.strokeStyle = color; ctx.lineWidth = b.broken ? 10 : 6;
      ctx.stroke();
    }
  }
  // Break point circles
  for (const bp of failureData.breakPoints) {
    ctx.beginPath(); ctx.arc(bp.x,bp.y,25+pulse*10,0,Math.PI*2);
    ctx.fillStyle=`rgba(244,67,54,${0.15+pulse*0.15})`;
    ctx.fill();
    ctx.strokeStyle=`rgba(244,67,54,${0.5+pulse*0.3})`;
    ctx.lineWidth=3; ctx.stroke();
    // Arrow pointing to break
    ctx.fillStyle='#F44336'; ctx.font='bold 18px sans-serif'; ctx.textAlign='center';
    ctx.fillText('âœ•',bp.x,bp.y+6);
  }
  // Legend
  ctx.fillStyle='rgba(0,0,0,0.75)';
  roundRect(ctx,canvas.width/2-100,10,200,55,8); ctx.fill();
  ctx.font='bold 12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillStyle='#F44336'; ctx.fillText('ğŸ” ANALYZING STRESS...',canvas.width/2,25);
  ctx.font='11px sans-serif';
  ctx.fillStyle='#4CAF50'; ctx.fillText('â— Safe',canvas.width/2-60,43);
  ctx.fillStyle='#FFC107'; ctx.fillText('â— Stressed',canvas.width/2,43);
  ctx.fillStyle='#F44336'; ctx.fillText('â— Broke',canvas.width/2+60,43);
  ctx.font='10px sans-serif'; ctx.fillStyle='#aaa';
  ctx.fillText('Tap a red âœ• to learn why!',canvas.width/2,57);
}

function roundRect(ctx,x,y,w,h,r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// â”€â”€ PHYSICS â”€â”€
function stepPhysics(speedMult) {
  const l = getLevel();
  const w = getWorld();
  const sm = speedMult || 1;
  for (const n of physicsNodes) {
    if (n.fixed) continue;
    const vx=(n.x-n.px)*DAMPING*sm;
    const vy=(n.y-n.py)*DAMPING*sm;
    n.px=n.x; n.py=n.y;
    const gMult = whatIfOverrides ? whatIfOverrides.gravMult : 1;
    n.x+=vx; n.y+=vy+GRAVITY*sm*gMult;
    // Wind
    const windBase = l.windForce || 0;
    const windExtra = whatIfOverrides ? whatIfOverrides.windPct * 0.3 : 0;
    if ((windBase || windExtra) && isTesting) n.x += (windBase + windExtra)*sm;
  }
  // Vehicle force
  if (vehicle && vehicle.active && vehicle.moving) {
    const roadNodes=physicsNodes.filter(n=>n.gy===l.roadY).sort((a,b)=>a.gx-b.gx);
    if (roadNodes.length>=2) {
      for (let i=0;i<roadNodes.length-1;i++) {
        const a=roadNodes[i], b=roadNodes[i+1];
        if (vehicle.x>=a.x && vehicle.x<=b.x) {
          const t=(vehicle.x-a.x)/(b.x-a.x||1);
          const wMult = whatIfOverrides ? whatIfOverrides.weightMult : 1;
          const force=l.vehicleWeight*wMult*GRAVITY*3*sm;
          if (!a.fixed) a.y+=force*(1-t)*0.5;
          if (!b.fixed) b.y+=force*t*0.5;
          vehicle.y=a.y+(b.y-a.y)*t;
          break;
        }
      }
    }
  }
  // Weight force
  if (weightObj && weightObj.active && weightObj.landed) {
    const topNodes = physicsNodes.filter(n=>!n.fixed).sort((a,b)=>a.y-b.y);
    const targetNodes = topNodes.slice(0, Math.max(2, Math.floor(topNodes.length*0.2)));
    for (const n of targetNodes) {
      const wMult2 = whatIfOverrides ? whatIfOverrides.weightMult : 1;
      n.y += (l.testWeight||3)*wMult2*GRAVITY*0.5*sm / targetNodes.length;
    }
    // Update weight position to sit on top
    if (targetNodes.length>0) {
      const avgX = targetNodes.reduce((s,n)=>s+n.x,0)/targetNodes.length;
      const minY = Math.min(...targetNodes.map(n=>n.y));
      weightObj.x = avgX;
      weightObj.y = minY - 20;
    }
  }
  // Constraints
  for (let iter=0;iter<ITERATIONS;iter++) {
    for (const b of physicsBeams) {
      if (b.broken) continue;
      const dx=b.b.x-b.a.x, dy=b.b.y-b.a.y;
      const dist=Math.sqrt(dx*dx+dy*dy)||0.001;
      const diff=(b.restLength-dist)/dist;
      const ox=dx*diff*0.5, oy=dy*diff*0.5;
      if (!b.a.fixed) { b.a.x-=ox; b.a.y-=oy; }
      if (!b.b.fixed) { b.b.x+=ox; b.b.y+=oy; }
      b.stress = Math.abs(dist-b.restLength)/b.restLength;
    }
  }
  // Break
  for (const b of physicsBeams) {
    if (b.broken) continue;
    const w2 = getWorld();
    const mat = w2.materials[b.material];
    if (b.stress > mat.maxStress*BREAK_MULT) { b.broken=true; sfx.play('breakBeam'); buddy.say('break'); }
  }
  return physicsNodes.some(n=>!n.fixed&&n.y>800);
}

// â”€â”€ FAILURE ANALYSIS â”€â”€
function analyzeFailure() {
  const broken = physicsBeams.filter(b=>b.broken);
  const allBeams = physicsBeams.length;
  const l = getLevel();
  const w = getWorld();

  const breakPoints = broken.map(b => ({x:(b.a.x+b.b.x)/2, y:(b.a.y+b.b.y)/2}));

  // Where did most beams break?
  let avgX=canvas.width/2;
  if (breakPoints.length>0) avgX = breakPoints.reduce((s,p)=>s+p.x,0)/breakPoints.length;
  const midX = canvas.width/2;
  const area = avgX<midX*0.7?'left side':avgX>midX*1.3?'right side':'center';

  // Check for triangles
  let hasTriangles = false;
  for (let i=0;i<gameBeams.length&&!hasTriangles;i++) {
    for (let j=i+1;j<gameBeams.length&&!hasTriangles;j++) {
      const shared = [gameBeams[i].a,gameBeams[i].b].filter(n=>[gameBeams[j].a,gameBeams[j].b].includes(n));
      if (shared.length===1) {
        const otherI = gameBeams[i].a===shared[0]?gameBeams[i].b:gameBeams[i].a;
        const otherJ = gameBeams[j].a===shared[0]?gameBeams[j].b:gameBeams[j].a;
        if (gameBeams.some(b=>!b.broken&&((b.a===otherI&&b.b===otherJ)||(b.a===otherJ&&b.b===otherI)))) hasTriangles=true;
      }
    }
  }

  const matKeys = Object.keys(w.materials);
  const allFirstMat = broken.length>0 && broken.every(b=>b.material===matKeys[0]);
  const fewBeams = allBeams < l.par*0.6;

  let cause, hint;
  const eTypeF = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eTypeF==='circuit') {
    cause = "Not all bulbs are connected to a battery!";
    hint = "Make sure every bulb has a wire path leading back to a battery.";
  } else if (w.id==='castle' || w.id==='towers') {
    // Tower-specific hints
    if (fewBeams) {
      cause = "Not enough beams to reach the target height!";
      hint = "Build upward from the ground! Connect dots vertically and add cross-bracing (X shapes) to keep it stable.";
    } else if (!hasTriangles && allBeams >= 4) {
      cause = "Your tower is wobbling â€” it needs cross-bracing!";
      hint = "Add diagonal beams between the vertical ones to make X shapes. This stops the tower from swaying side to side!";
    } else if (allFirstMat && matKeys.length>1 && currentLevel>=2) {
      cause = `${w.materials[matKeys[0]].name} wasn't strong enough at the base!`;
      hint = `Use ${w.materials[matKeys[1]].name} for the lower beams â€” the base carries the most weight.`;
    } else {
      cause = `The ${area} of your tower gave way!`;
      hint = `Make the base wider and add cross-bracing (X shapes) to the ${area}. A wider base means a stronger tower!`;
    }
  } else {
    // Bridge-specific hints (default)
    if (fewBeams) {
      cause = "Not enough beams to support the load!";
      hint = "Add more beams â€” try connecting every nearby pair of dots for extra strength.";
    } else if (!hasTriangles && allBeams >= 4) {
      cause = "Your bridge has rectangular shapes that bend easily under stress!";
      hint = "Add diagonal beams to form triangles â€” triangles are the strongest shape in bridge building!";
    } else if (allFirstMat && matKeys.length>1 && currentLevel>=2) {
      cause = `${w.materials[matKeys[0]].name} wasn't strong enough for this heavy load!`;
      hint = `Try using ${w.materials[matKeys[1]].name} beams in the ${area} where stress is highest.`;
    } else if (broken.length > allBeams*0.5) {
      cause = "Too many beams failed at once â€” the bridge needs better support!";
      hint = `Strengthen the ${area} with more triangles and connect beams to the supports on each side.`;
    } else {
      cause = `The ${area} couldn't handle the stress and collapsed!`;
      hint = `Add more support to the ${area}. Try diagonal beams or stronger materials there.`;
    }
  }

  return { cause, hint, breakPoints };
}

function startFailureAnalysis() {
  failurePhase = 'slowmo';
  failureFrames = 0;
  failureData = analyzeFailure();

  // Store hint for retry
  const hk = starKey(currentWorld, currentLevel);
  lastHint[hk] = failureData.hint;

  // Track attempts
  const ak = starKey(currentWorld, currentLevel);
  levelAttempts[ak] = (levelAttempts[ak]||0) + 1;
  saveProgress();
}

function continueAfterFailure() {
  failurePhase = null;
  if (animId) cancelAnimationFrame(animId);
  document.getElementById('failureOverlay').classList.remove('active');
  isTesting = false;
  vehicle = null;
  weightObj = null;
  showResult(false, 0);
}

// â”€â”€ TESTS â”€â”€
function startTest() {
  const w = getWorld();
  const l = getLevel();
  const eType = (w.testType==='castle') ? l.castlePhase : w.testType;
  if (eType==='arch') {
    if (!archState || archState.placed.size===0) return;
    startArchTest(); return;
  }
  if (gameBeams.length===0) return;
  buddy.say('testing'); buddy.stop();
  if (eType==='circuit') { startCircuitTest(); return; }

  isTesting = true;
  helpVisible = false;
  failurePhase = null; failureData = null;
  document.getElementById('helpOverlay').style.display='none';
  document.getElementById('hintBanner').classList.remove('active');
  document.getElementById('bottomBar').style.display='none';
  document.getElementById('testingBar').style.display='block';
  document.getElementById('clearBtn').disabled=true;
  document.getElementById('failureOverlay').classList.remove('active');

  // Deep clone
  physicsNodes = gameNodes.map(n=>({...n}));
  physicsBeams = gameBeams.map(b=>({
    ...b,
    a: physicsNodes.find(n=>n.gx===b.a.gx&&n.gy===b.a.gy),
    b: physicsNodes.find(n=>n.gx===b.b.gx&&n.gy===b.b.gy)
  }));

  if (eType==='flight' || w.testType==='flight') startFlightTest();
  else if (eType==='vehicle' || w.testType==='vehicle') startVehicleTest();
  else startWeightTest(); // handles 'weight', 'tower', and castle tower phases
}

function startVehicleTest() {
  const l = getLevel();
  const startX = 40+l.roadStartX*l.cellSize;
  const endX = 40+l.roadEndX*l.cellSize;
  vehicle = { x:startX-30, y:40+l.roadY*l.cellSize, active:true, moving:false, progress:0 };
  let settleFrames = 0;

  function loop() {
    if (failurePhase==='slowmo') {
      failureFrames++;
      stepPhysics(0.25);
      drawGame();
      if (failureFrames>100) {
        failurePhase='analysis';
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
        return;
      }
      animId=requestAnimationFrame(loop); return;
    }

    settleFrames++;
    if (settleFrames>45) vehicle.moving=true;
    const fell = stepPhysics(1);

    if (vehicle.moving) {
      vehicle.x += l.vehicleSpeed*1.3;
      vehicle.progress = (vehicle.x-40-l.roadStartX*l.cellSize)/(40+l.roadEndX*l.cellSize-40-l.roadStartX*l.cellSize);
      document.getElementById('progressFill').style.width = Math.max(0,Math.min(100,vehicle.progress*100))+'%';
      if (vehicle.x >= endX+25) {
        isTesting=false; vehicle.active=false;
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
        return;
      }
    }

    if (fell || physicsBeams.filter(b=>!b.broken).length===0 || (vehicle.moving&&vehicle.y>600)) {
      if (!failurePhase) { startFailureAnalysis(); }
    }

    drawGame();
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

function startWeightTest() {
  const l = getLevel();
  // Find center top of structure
  const nonFixed = physicsNodes.filter(n=>!n.fixed);
  let centerX = canvas.width/2;
  if (nonFixed.length>0) centerX = nonFixed.reduce((s,n)=>s+n.x,0)/nonFixed.length;
  weightObj = { x:centerX, y:-20, active:true, landed:false, holdFrames:0 };
  let settleFrames = 0;

  function loop() {
    if (failurePhase==='slowmo') {
      failureFrames++;
      stepPhysics(0.25);
      drawGame();
      if (failureFrames>100) {
        failurePhase='analysis';
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
        return;
      }
      animId=requestAnimationFrame(loop); return;
    }

    settleFrames++;
    const fell = stepPhysics(1);

    // Lower the weight
    if (settleFrames>30 && !weightObj.landed) {
      weightObj.y += 2;
      const topNodes = physicsNodes.filter(n=>!n.fixed).sort((a,b)=>a.y-b.y);
      if (topNodes.length>0 && weightObj.y >= topNodes[0].y - 30) {
        weightObj.landed = true;
      }
    }

    if (weightObj.landed) {
      weightObj.holdFrames++;
      const progress = weightObj.holdFrames/150;
      document.getElementById('progressFill').style.width = Math.min(100,progress*100)+'%';

      if (weightObj.holdFrames >= 150) {
        isTesting=false; weightObj.active=false;
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
        return;
      }
    }

    if (fell || physicsBeams.filter(b=>!b.broken).length===0) {
      if (!failurePhase) { startFailureAnalysis(); }
    }

    drawGame();
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

function startFlightTest() {
  const l = getLevel();
  const w = getWorld();
  // Calculate lift and drag from beam geometry (Bernoulli + Newton's 3rd law)
  let totalLift = 0, totalDrag = 0, totalWeight = 0;
  for (const b of gameBeams) {
    const dx = b.b.x - b.a.x;
    const dy = b.b.y - b.a.y;
    const len = Math.sqrt(dx*dx + dy*dy) || 1;
    // Upward angle in screen coords (negative dy = upward)
    const upwardness = -dy / len; // 1 = straight up, 0 = horizontal, -1 = straight down
    const horizontalSpan = Math.abs(dx);
    // LIFT: beams angled upward deflect air downward â†’ Newton's 3rd law pushes wing UP
    // More horizontal span (wingspan) = more air deflected = more lift
    const liftContrib = Math.max(0, upwardness * 0.4 + 0.3) * horizontalSpan * 0.02 * (l.windSpeed||1);
    // DRAG: vertical area facing the wind creates resistance
    // Pure horizontal beams have low drag; vertical beams have high drag
    const verticalArea = Math.abs(dy);
    const dragContrib = (verticalArea * 0.012 + len * 0.002) * (l.dragMult||1);
    // WEIGHT: every beam adds weight; carbon fiber is 40% lighter
    const matWeight = (b.material==='carbon'||b.material==='fiber') ? 0.6 : 1.0;
    totalLift += liftContrib;
    totalDrag += dragContrib;
    totalWeight += len * 0.008 * matWeight;
  }
  // Net flight performance: lift must overcome weight and drag
  const netLift = totalLift - totalWeight*0.5 - totalDrag*0.3;
  const maxAltitude = Math.max(0, netLift * 55);

  flightState = { lift: totalLift, drag: totalDrag, weight: totalWeight, altitude: 0, maxAlt: maxAltitude, active: true, frame: 0 };

  function loop() {
    flightState.frame++;
    const progress = flightState.frame / 200;
    // Smooth climb: ease-in to max altitude
    const climbPct = Math.min(1, flightState.frame / 120);
    flightState.altitude = flightState.maxAlt * (1 - Math.pow(1 - climbPct, 2.5));
    document.getElementById('progressFill').style.width = Math.min(100, progress*100)+'%';

    drawGame();

    if (flightState.frame >= 200) {
      isTesting = false;
      flightState.active = false;
      if (flightState.maxAlt >= l.flightTarget) {
        // Success!
        const stars = gameBeams.length <= l.par ? 3 : gameBeams.length <= l.par + 4 ? 2 : 1;
        const sk = starKey(currentWorld, currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
      } else {
        // Failed - not enough lift
        const pct = Math.floor((flightState.maxAlt / l.flightTarget) * 100);
        failureData = {
          breakPoints: [],
          cause: `Your aircraft only reached ${Math.floor(flightState.maxAlt)} ft (needed ${l.flightTarget} ft â€” ${pct}% there)!`,
          hint: totalLift < totalDrag ? "Too much drag! Use fewer vertical beams and more angled ones (â†—)."
            : totalWeight > totalLift ? "Too heavy! Use fewer beams or switch to Carbon Fiber for less weight."
            : "Add more angled beams pointing upward to increase lift. Wider wingspan helps too!"
        };
        const ak = `${currentWorld}_${currentLevel}`;
        levelAttempts[ak] = (levelAttempts[ak]||0) + 1;
        lastHint[starKey(currentWorld,currentLevel)] = failureData.hint;
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
        document.getElementById('testingBar').style.display='none';
        sfx.play('fail');
        buddy.say('break');
      }
      return;
    }
    animId = requestAnimationFrame(loop);
  }
  animId = requestAnimationFrame(loop);
}

function startCircuitTest() {
  const l = getLevel();
  isTesting = true;
  helpVisible = false;
  document.getElementById('helpOverlay').style.display='none';
  document.getElementById('hintBanner').classList.remove('active');
  document.getElementById('bottomBar').style.display='none';
  document.getElementById('testingBar').style.display='block';
  document.getElementById('clearBtn').disabled=true;
  document.getElementById('failureOverlay').classList.remove('active');

  physicsNodes = gameNodes.map(n=>({...n}));
  physicsBeams = gameBeams.map(b=>({
    ...b,
    a: physicsNodes.find(n=>n.gx===b.a.gx&&n.gy===b.a.gy),
    b: physicsNodes.find(n=>n.gx===b.b.gx&&n.gy===b.b.gy)
  }));

  // BFS from sources
  circuitReached = new Set();
  circuitParticles = [];
  const sources = physicsNodes.filter(n=>n.nodeType==='source');
  const targets = physicsNodes.filter(n=>n.nodeType==='target');
  const queue = [...sources];
  queue.forEach(n=>circuitReached.add(n));

  while (queue.length>0) {
    const cur = queue.shift();
    for (const wire of physicsBeams) {
      const other = wire.a===cur?wire.b:wire.b===cur?wire.a:null;
      if (other && !circuitReached.has(other)) {
        circuitReached.add(other);
        queue.push(other);
      }
    }
  }

  const allPowered = targets.every(t=>circuitReached.has(t));

  // Create particles along powered wires
  for (const wire of physicsBeams) {
    if (circuitReached.has(wire.a) && circuitReached.has(wire.b)) {
      for (let i=0;i<3;i++) {
        circuitParticles.push({
          wire, t:Math.random(), speed:0.01+Math.random()*0.01,
          x:wire.a.x, y:wire.a.y
        });
      }
    }
  }

  let frames = 0;
  function loop() {
    frames++;
    // Animate particles
    for (const p of circuitParticles) {
      p.t += p.speed;
      if (p.t>1) p.t-=1;
      p.x = p.wire.a.x + (p.wire.b.x-p.wire.a.x)*p.t;
      p.y = p.wire.a.y + (p.wire.b.y-p.wire.a.y)*p.t;
    }
    document.getElementById('progressFill').style.width = Math.min(100,frames/120*100)+'%';

    drawGame();

    if (frames >= 120) {
      isTesting=false;
      if (allPowered) {
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
      } else {
        // Failure for circuits
        const unpowered = targets.filter(t=>!circuitReached.has(t));
        failureData = {
          cause: `${unpowered.length} bulb${unpowered.length>1?'s are':' is'} not connected to a battery!`,
          hint: 'Make sure every bulb has a wire path leading back to a battery. Check for gaps!',
          breakPoints: unpowered.map(n=>({x:n.x,y:n.y}))
        };
        const hk = starKey(currentWorld,currentLevel);
        lastHint[hk] = failureData.hint;
        levelAttempts[hk] = (levelAttempts[hk]||0)+1;
        saveProgress();
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
      }
      return;
    }
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

// â”€â”€ ARCH MODE â”€â”€
let archState = null; // { slots:[], placed:Set, pillarSlots:[], keystoneIdx }

function initArchSlots(l) {
  const slots = [];
  const n = l.archSlots;
  const cx = l.archCx, cy = l.archCy, rx = l.archRx, ry = l.archRy;
  // All arch types: distribute n slots evenly along a semicircle
  for (let i=0;i<n;i++) {
    const t = i/(n-1);
    const ang = Math.PI * (1-t); // left to right
    let x = cx + rx*Math.cos(ang);
    let y = cy - ry*Math.sin(ang);
    // Gothic: raise the center stones to create a pointed peak
    if (l.archType === 'gothic') {
      const center = Math.abs(t - 0.5);
      const lift = (0.5 - center) * ry * 0.5;
      y -= lift;
    }
    slots.push({x,y,ang,idx:i});
  }
  const keystoneIdx = Math.floor(n/2);
  slots.forEach((s,i) => { s.isKeystone = (i===keystoneIdx); });
  return { slots, keystoneIdx };
}

function generateArchSlotShapes(l) {
  const n = l.archSlots;
  const cx = l.archCx, cy = l.archCy, rx = l.archRx, ry = l.archRy;
  const outerR = 1.22; // outer radius multiplier (bigger = thicker stones)
  const innerR = 0.78; // inner radius multiplier
  const shapes = [];

  // Helper: get point on arch curve at parameter t (0=left pillar, 1=right pillar)
  function archPoint(t, radiusMult) {
    const ang = Math.PI * (1-t);
    let x = cx + rx * radiusMult * Math.cos(ang);
    let y = cy - ry * radiusMult * Math.sin(ang);
    if (l.archType === 'gothic') {
      const center = Math.abs(t - 0.5);
      const lift = (0.5 - center) * ry * radiusMult * 0.5;
      y -= lift;
    }
    return {x, y};
  }

  // Each voussoir spans from t_i to t_{i+1} with radial edges
  // Edges between stones are SHARED â€” no gaps!
  for (let i=0; i<n; i++) {
    const t1 = i / n;
    const t2 = (i+1) / n;
    const tMid = (t1+t2)/2;

    // Four corners of the voussoir (trapezoid/wedge shape)
    // outer-left, outer-right, inner-right, inner-left
    const oL = archPoint(t1, outerR);
    const oR = archPoint(t2, outerR);
    const iR = archPoint(t2, innerR);
    const iL = archPoint(t1, innerR);

    // Add intermediate points along the curves for smoother rendering
    const outerPts = [oL];
    const innerPts = [iL];
    const steps = 4;
    for (let s=1; s<steps; s++) {
      const tS = t1 + (t2-t1)*s/steps;
      outerPts.push(archPoint(tS, outerR));
      innerPts.push(archPoint(tS, innerR));
    }
    outerPts.push(oR);
    innerPts.push(iR);

    const center = archPoint(tMid, 1.0);

    shapes.push({
      outer: outerPts,
      inner: innerPts,
      // Keep 2-point versions for hit testing compatibility
      outerEdge: [oL, oR],
      innerEdge: [iL, iR],
      cx: center.x,
      cy: center.y,
      t1, t2
    });
  }
  return shapes;
}

function startArchGame() {
  const l = getLevel();
  const as = initArchSlots(l);
  const shapes = generateArchSlotShapes(l);
  archState = { slots:as.slots, keystoneIdx:as.keystoneIdx, placed:new Set(), prePlaced:new Set(), shapes, material:'stone', testPhase:null, testFrames:0, weightY:-30, weightLanded:false, crumbleOffsets:[] };
  // Pre-place stones if level defines them
  if (l.prePlaced) {
    for (const idx of l.prePlaced) { archState.placed.add(idx); archState.prePlaced.add(idx); }
  }
  // For double aqueduct, create second arch
  if (l.archType==='double') {
    const l2 = {...l, archCx:l.archCx2};
    const as2 = initArchSlots(l2);
    const shapes2 = generateArchSlotShapes(l2);
    archState.slots2 = as2.slots;
    archState.shapes2 = shapes2;
    archState.placed2 = new Set();
    archState.prePlaced2 = new Set();
    archState.keystoneIdx2 = as2.keystoneIdx;
  }
}

function drawArchWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Warm stone sky
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#FFE0B2'); sg.addColorStop(1,'#FFF3E0');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  drawClouds(W);

  // Water below
  ctx.fillStyle='#29B6F6';
  ctx.fillRect(0,l.archCy+10,W,H-l.archCy-10);
  ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5;
  const wt=Date.now()*0.003;
  ctx.beginPath();
  for (let px=0;px<W;px+=3) ctx.lineTo(px,l.archCy+18+Math.sin(wt+px*0.06)*2);
  ctx.stroke();

  // Draw pillars
  const drawPillar = (px,py,pw,ph) => {
    ctx.fillStyle='#8D6E63';
    ctx.fillRect(px-pw/2,py,pw,ph);
    ctx.strokeStyle='#5D4037'; ctx.lineWidth=2;
    ctx.strokeRect(px-pw/2,py,pw,ph);
    // Stone lines
    for (let row=0;row<Math.floor(ph/15);row++) {
      const ry2=py+row*15;
      ctx.beginPath(); ctx.moveTo(px-pw/2,ry2); ctx.lineTo(px+pw/2,ry2); ctx.strokeStyle='#6D4C41'; ctx.lineWidth=1; ctx.stroke();
      if (row%2===0) { ctx.beginPath(); ctx.moveTo(px,ry2); ctx.lineTo(px,ry2+15); ctx.stroke(); }
      else { ctx.beginPath(); ctx.moveTo(px-pw/4,ry2); ctx.lineTo(px-pw/4,ry2+15); ctx.stroke(); ctx.beginPath(); ctx.moveTo(px+pw/4,ry2); ctx.lineTo(px+pw/4,ry2+15); ctx.stroke(); }
    }
  };
  // Left and right pillars
  const pillarTop = l.archCy;
  drawPillar(l.archCx-l.archRx, pillarTop, l.archPillarW, l.archPillarH);
  drawPillar(l.archCx+l.archRx, pillarTop, l.archPillarW, l.archPillarH);
  if (l.archType==='double') {
    drawPillar(l.archCx2-l.archRx, pillarTop, l.archPillarW, l.archPillarH);
    drawPillar(l.archCx2+l.archRx, pillarTop, l.archPillarW, l.archPillarH);
  }

  // Draw ghost slots and placed stones
  if (archState) {
    const drawArchStones = (shapes, slots, placed, keystoneIdx) => {
      // Helper to trace the voussoir polygon (outer forward, inner backward)
      function traceStone(sh, offX, offY) {
        ctx.beginPath();
        for (let p=0; p<sh.outer.length; p++) {
          const pt = sh.outer[p];
          if (p===0) ctx.moveTo(pt.x+offX, pt.y+offY);
          else ctx.lineTo(pt.x+offX, pt.y+offY);
        }
        for (let p=sh.inner.length-1; p>=0; p--) {
          ctx.lineTo(sh.inner[p].x+offX, sh.inner[p].y+offY);
        }
        ctx.closePath();
      }

      for (let i=0;i<shapes.length;i++) {
        const sh = shapes[i];
        const isPlaced = placed.has(i);
        const isKeystone = (i===keystoneIdx);

        if (isPlaced) {
          const off = (archState.testPhase==='crumble' && archState.crumbleOffsets[i]) || {x:0,y:0,r:0};
          ctx.save();
          if (off.r) {
            ctx.translate(sh.cx+off.x, sh.cy+off.y);
            ctx.rotate(off.r);
            ctx.translate(-(sh.cx+off.x), -(sh.cy+off.y));
          }
          traceStone(sh, off.x, off.y);
          if (isKeystone) {
            ctx.fillStyle = archState.material==='marble'?'#CFD8DC':'#D4A574';
            ctx.strokeStyle = '#FFD600'; ctx.lineWidth=3;
          } else {
            ctx.fillStyle = archState.material==='marble'?'#B0BEC5':'#A1887F';
            ctx.strokeStyle = '#5D4037'; ctx.lineWidth=1.5;
          }
          ctx.fill(); ctx.stroke();
          // Stone texture â€” subtle cracks
          ctx.strokeStyle='rgba(0,0,0,0.06)'; ctx.lineWidth=0.8;
          ctx.beginPath();
          ctx.moveTo(sh.cx+off.x-6,sh.cy+off.y-2);
          ctx.lineTo(sh.cx+off.x+4,sh.cy+off.y+4);
          ctx.moveTo(sh.cx+off.x+2,sh.cy+off.y-5);
          ctx.lineTo(sh.cx+off.x-3,sh.cy+off.y+3);
          ctx.stroke();
          // Number label for educational ordering
          ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.font='bold 9px sans-serif';
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(isKeystone?'â˜…':`${i+1}`,sh.cx+off.x,sh.cy+off.y);
          ctx.restore();
        } else {
          // Ghost slot â€” wedge-shaped outline showing where stone goes
          const pulse = isKeystone ? 0.2 + Math.sin(Date.now()*0.005)*0.12 : 0;
          traceStone(sh, 0, 0);
          ctx.fillStyle = isKeystone ? `rgba(255,214,0,${0.15+pulse})` : 'rgba(141,110,99,0.1)';
          ctx.fill();
          ctx.strokeStyle = isKeystone ? `rgba(255,214,0,${0.6+pulse})` : 'rgba(141,110,99,0.3)';
          ctx.lineWidth = isKeystone ? 3 : 1.5;
          if (!isKeystone) { ctx.setLineDash([5,4]); }
          ctx.stroke(); ctx.setLineDash([]);
          // Label
          ctx.fillStyle = isKeystone ? '#FFD600' : 'rgba(141,110,99,0.6)';
          ctx.font = isKeystone ? 'bold 13px sans-serif' : '10px sans-serif';
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(isKeystone?'â˜… KEY':'tap',sh.cx,sh.cy);
          // Glow for keystone
          if (isKeystone) {
            ctx.beginPath(); ctx.arc(sh.cx,sh.cy,30,0,Math.PI*2);
            ctx.fillStyle=`rgba(255,214,0,${0.06+pulse*0.3})`; ctx.fill();
          }
        }
      }
    };
    drawArchStones(archState.shapes, archState.slots, archState.placed, archState.keystoneIdx);
    if (l.archType==='double' && archState.shapes2) {
      drawArchStones(archState.shapes2, archState.slots2, archState.placed2, archState.keystoneIdx2);
    }

    // Arch drag visualization: highlight dragged stone + target slot
    if (dragState && dragState.type==='arch' && dragState.moved && dragState.dragPt) {
      const shapes = dragState.archSet===1 ? archState.shapes : archState.shapes2;
      const srcSh = shapes[dragState.idx];
      // Draw dragged stone at finger position
      const offX = dragState.dragPt.x - srcSh.cx;
      const offY = dragState.dragPt.y - srcSh.cy;
      ctx.save(); ctx.globalAlpha=0.6;
      ctx.beginPath();
      for (let p=0;p<srcSh.outer.length;p++) {
        const pt2 = srcSh.outer[p];
        if(p===0) ctx.moveTo(pt2.x+offX,pt2.y+offY); else ctx.lineTo(pt2.x+offX,pt2.y+offY);
      }
      for (let p=srcSh.inner.length-1;p>=0;p--) ctx.lineTo(srcSh.inner[p].x+offX,srcSh.inner[p].y+offY);
      ctx.closePath();
      ctx.fillStyle='#FF9800'; ctx.fill();
      ctx.strokeStyle='#E65100'; ctx.lineWidth=2; ctx.stroke();
      ctx.restore();
      // Highlight target slot with green glow
      if (dragState.nearestEmpty >= 0) {
        const tgtSh = shapes[dragState.nearestEmpty];
        ctx.save(); ctx.globalAlpha=0.35;
        ctx.beginPath();
        for (let p=0;p<tgtSh.outer.length;p++) {
          if(p===0) ctx.moveTo(tgtSh.outer[p].x,tgtSh.outer[p].y); else ctx.lineTo(tgtSh.outer[p].x,tgtSh.outer[p].y);
        }
        for (let p=tgtSh.inner.length-1;p>=0;p--) ctx.lineTo(tgtSh.inner[p].x,tgtSh.inner[p].y);
        ctx.closePath();
        ctx.fillStyle='#4CAF50'; ctx.fill();
        ctx.strokeStyle='#2E7D32'; ctx.lineWidth=3; ctx.stroke();
        ctx.restore();
      }
    }

    // Draw guide curve (faint)
    const drawGuideCurve = (cx2, cy2, rx2, ry2, type) => {
      ctx.strokeStyle='rgba(141,110,99,0.15)'; ctx.lineWidth=1; ctx.setLineDash([4,6]);
      ctx.beginPath();
      for (let i=0;i<=40;i++) {
        const t=i/40;
        const ang=Math.PI*(1-t);
        let x=cx2+rx2*Math.cos(ang), y=cy2-ry2*Math.sin(ang);
        if (type==='gothic') { const c=Math.abs(t-0.5); y-=(0.5-c)*ry2*0.5; }
        if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
      }
      ctx.stroke(); ctx.setLineDash([]);
    };
    drawGuideCurve(l.archCx, l.archCy, l.archRx, l.archRy, l.archType);
    if (l.archType==='double') drawGuideCurve(l.archCx2, l.archCy, l.archRx, l.archRy, l.archType);

    // Weight during test
    if (archState.testPhase) {
      const wx = l.archType==='double' ? (l.archCx+l.archCx2)/2 : l.archCx;
      const wy = archState.weightY;
      ctx.fillStyle='#455A64';
      ctx.beginPath();
      ctx.moveTo(wx-20,wy); ctx.lineTo(wx+20,wy); ctx.lineTo(wx+15,wy+25); ctx.lineTo(wx-15,wy+25); ctx.closePath();
      ctx.fill(); ctx.strokeStyle='#263238'; ctx.lineWidth=2; ctx.stroke();
      ctx.fillStyle='#fff'; ctx.font='bold 12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('â¬‡ï¸',wx,wy+12);
    }
  }
}

function pointInVoussoir(pt, sh) {
  // Build polygon from outer points (forward) + inner points (reversed)
  const poly = [...sh.outer, ...([...sh.inner].reverse())];
  let inside = false;
  for (let i=0,j=poly.length-1; i<poly.length; j=i++) {
    if ((poly[i].y>pt.y)!==(poly[j].y>pt.y) &&
      pt.x<(poly[j].x-poly[i].x)*(pt.y-poly[i].y)/(poly[j].y-poly[i].y)+poly[i].x) {
      inside = !inside;
    }
  }
  return inside;
}

function archHitTest(pt, shapes, placed, skipPlaced) {
  // Find closest shape, using point-in-polygon + generous radius
  let best=-1, bestD=999;
  for (let i=0;i<shapes.length;i++) {
    if (skipPlaced && placed.has(i)) continue;
    if (!skipPlaced && !placed.has(i)) continue;
    const sh = shapes[i];
    // Point-in-polygon first (exact)
    if (pointInVoussoir(pt, sh)) return i;
    // Fallback: distance to center with generous radius
    const d = Math.hypot(pt.x-sh.cx, pt.y-sh.cy);
    if (d < 50 && d < bestD) { bestD = d; best = i; }
  }
  return best;
}

function handleArchTap(pt) {
  if (!archState || archState.testPhase) return;
  const l = getLevel();
  const tryPlace = (shapes, placed, keystoneIdx, prePlaced) => {
    const hit = archHitTest(pt, shapes, placed, true);
    if (hit >= 0 && !(prePlaced && prePlaced.has(hit))) {
      placed.add(hit);
      sfx.play('place');
      // Auto-fill: when user taps one non-keystone slot, fill ALL non-keystone non-puzzle slots
      if (hit !== keystoneIdx && l.autoFill) {
        for (let i=0;i<shapes.length;i++) {
          if (i !== keystoneIdx && !placed.has(i) && !(prePlaced && prePlaced.has(i))) placed.add(i);
        }
      }
      return true;
    }
    return false;
  };
  if (tryPlace(archState.shapes, archState.placed, archState.keystoneIdx, archState.prePlaced)) { updateArchUI(); drawGame(); return; }
  if (l.archType==='double' && archState.shapes2) {
    if (tryPlace(archState.shapes2, archState.placed2, archState.keystoneIdx2, archState.prePlaced2)) { updateArchUI(); drawGame(); return; }
  }
}

function handleArchRemove(pt) {
  if (!archState || archState.testPhase) return;
  const l = getLevel();
  const tryRemove = (shapes, placed, prePlaced) => {
    const hit = archHitTest(pt, shapes, placed, false);
    if (hit >= 0 && !(prePlaced && prePlaced.has(hit))) {
      placed.delete(hit);
      sfx.play('remove');
      return true;
    }
    return false;
  };
  if (tryRemove(archState.shapes, archState.placed, archState.prePlaced)) { updateArchUI(); drawGame(); return; }
  if (l.archType==='double' && archState.shapes2) {
    if (tryRemove(archState.shapes2, archState.placed2, archState.prePlaced2)) { updateArchUI(); drawGame(); return; }
  }
}

function updateArchUI() {
  const l = getLevel();
  let total = archState.placed.size;
  let max = archState.shapes.length;
  if (l.archType==='double') { total += archState.placed2.size; max += archState.shapes2.length; }
  document.getElementById('gameMeta').textContent = `Stones: ${total} / ${max} | Par: ${l.par}`;
  document.getElementById('testBtn').disabled = total===0;
}

function startArchTest() {
  const l = getLevel();
  buddy.say('testing'); buddy.stop();
  isTesting = true;
  document.getElementById('helpOverlay').style.display='none';
  document.getElementById('hintBanner').classList.remove('active');
  document.getElementById('bottomBar').style.display='none';
  document.getElementById('testingBar').style.display='block';
  document.getElementById('clearBtn').disabled=true;
  document.getElementById('failureOverlay').classList.remove('active');

  const totalPlaced = archState.placed.size + (l.archType==='double' ? archState.placed2.size : 0);
  const totalSlots = archState.shapes.length + (l.archType==='double' ? archState.shapes2.length : 0);
  const isComplete = totalPlaced === totalSlots;
  // Check if keystone(s) placed
  const keystonePlaced = archState.placed.has(archState.keystoneIdx) &&
    (l.archType!=='double' || archState.placed2.has(archState.keystoneIdx2));

  archState.testPhase = 'drop';
  archState.testFrames = 0;
  const topY = l.archCy - l.archRy - 60;
  archState.weightY = topY - 80;
  archState.weightLanded = false;
  archState.crumbleOffsets = [];
  for (let i=0;i<totalSlots;i++) archState.crumbleOffsets.push({x:0,y:0,r:0,vy:0,vx:0,vr:0});

  function loop() {
    archState.testFrames++;
    const progress = Math.min(1, archState.testFrames/180);
    document.getElementById('progressFill').style.width = (progress*100)+'%';

    if (archState.testPhase==='drop') {
      archState.weightY += 2.5;
      const landY = l.archCy - l.archRy*0.85;
      if (archState.weightY >= landY) {
        archState.weightY = landY;
        archState.weightLanded = true;
        if (isComplete && keystonePlaced) {
          archState.testPhase = 'hold';
          archState.testFrames = 0;
        } else {
          archState.testPhase = 'crumble';
          archState.testFrames = 0;
          // Initialize crumble velocities for unplaced or weak spots
          for (let i=0;i<archState.shapes.length;i++) {
            if (!archState.placed.has(i)) {
              // Neighbors fall too
              for (let j=Math.max(0,i-1);j<=Math.min(archState.shapes.length-1,i+1);j++) {
                archState.crumbleOffsets[j].vy = Math.random()*1.5;
                archState.crumbleOffsets[j].vx = (Math.random()-0.5)*2;
                archState.crumbleOffsets[j].vr = (Math.random()-0.5)*0.05;
              }
            }
          }
          if (!keystonePlaced) {
            // Without keystone, everything near the top crumbles
            const ki = archState.keystoneIdx;
            for (let j=Math.max(0,ki-2);j<=Math.min(archState.shapes.length-1,ki+2);j++) {
              archState.crumbleOffsets[j].vy = Math.random()*2;
              archState.crumbleOffsets[j].vx = (Math.random()-0.5)*3;
              archState.crumbleOffsets[j].vr = (Math.random()-0.5)*0.08;
            }
          }
        }
      }
    } else if (archState.testPhase==='hold') {
      // Arch holding! Show success after hold period
      if (archState.testFrames >= 120) {
        isTesting = false;
        archState.testPhase = null;
        const stars = totalPlaced<=l.par?3:totalPlaced<=l.par+3?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
        return;
      }
    } else if (archState.testPhase==='crumble') {
      // Animate crumbling
      for (let i=0;i<archState.crumbleOffsets.length;i++) {
        const o = archState.crumbleOffsets[i];
        o.vy += 0.3; // gravity
        o.x += o.vx; o.y += o.vy; o.r += o.vr;
      }
      if (archState.testFrames >= 100) {
        isTesting = false;
        archState.testPhase = null;
        // Failure analysis
        let cause, hint;
        if (!keystonePlaced) {
          cause = "The keystone is missing â€” nothing locks the arch together!";
          hint = "The keystone (â˜…) at the top is the most important stone. It wedges between the two sides and locks everything in place!";
        } else if (totalPlaced < totalSlots) {
          const missing = totalSlots - totalPlaced;
          cause = `${missing} stone${missing>1?'s are':' is'} missing â€” the arch has gaps!`;
          hint = "Every stone in an arch depends on its neighbors. A missing stone means the weight can't flow through the curve to the supports!";
        } else {
          cause = "The structure couldn't handle the weight!";
          hint = "Make sure all stones are placed and the keystone is in position!";
        }
        failureData = { cause, hint, breakPoints:[] };
        const hk = starKey(currentWorld,currentLevel);
        lastHint[hk] = hint;
        levelAttempts[hk] = (levelAttempts[hk]||0)+1;
        saveProgress();
        sfx.play('fail');
        document.getElementById('failureCause').textContent = cause;
        document.getElementById('failureHint').textContent = hint;
        document.getElementById('failureOverlay').classList.add('active');
        return;
      }
    }
    drawGame();
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

// â”€â”€ RESULT â”€â”€
function showResult(success, stars) {
  if (animId) cancelAnimationFrame(animId);

  // Handle H2H mode
  if (h2hState) {
    if (h2hState.phase === 'p1build' || h2hState.phase === 'p1test') {
      h2hState.p1result = { success, stars, beams: gameBeams.length };
      h2hState.p1beams = gameBeams.map(b => ({ aGx:b.a.gx, aGy:b.a.gy, bGx:b.b.gx, bGy:b.b.gy, material:b.material }));
      h2hState.phase = 'p2build';
      // Show pass-device screen
      showH2HPassDevice();
      return;
    }
    if (h2hState.phase === 'p2build' || h2hState.phase === 'p2test') {
      h2hState.p2result = { success, stars, beams: gameBeams.length };
      h2hState.phase = 'results';
      showH2HResults();
      return;
    }
  }

  // Handle Co-op mode
  if (coopState) {
    coopState = null;
    hidePlayerBanner();
  }

  const l = getLevel();
  const w = getWorld();
  const el = document.getElementById('result');
  el.className = 'screen active '+(success?'success':'fail');

  const successEmojis = { bridges:'ğŸ‰', towers:'ğŸ†', arches:'ğŸ›ï¸', circuits:'ğŸ’¡' };
  const failEmojis = { bridges:'ğŸ’¥', towers:'ğŸ’¨', arches:'ğŸª¨', circuits:'ğŸ”Œ' };
  const successTitles = { bridges:'BRIDGE HELD!', towers:'TOWER STOOD!', arches:'ARCH HELD!', circuits:'CIRCUIT WORKS!' };
  const failTitles = { bridges:'BRIDGE COLLAPSED!', towers:'TOWER FELL!', arches:'ARCH CRUMBLED!', circuits:'NO POWER!' };

  sfx.play(success ? 'success' : 'fail');
  document.getElementById('resultEmoji').textContent = success?successEmojis[w.id]:'ğŸ’¥';
  const title = document.getElementById('resultTitle');
  title.textContent = success?(successTitles[w.id]||'SUCCESS!'):(failTitles[w.id]||'FAILED!');
  title.className = 'result-title '+(success?'win':'lose');

  document.getElementById('resultStars').innerHTML = success?starsHTML(stars,40):'';

  const pc = document.getElementById('principleCard');
  if (success) {
    pc.style.display='block';
    document.getElementById('principleLabel').textContent = (l.principleIcon||'ğŸ“š')+' ENGINEERING PRINCIPLE';
    document.getElementById('principleBody').textContent = l.principle;
  } else pc.style.display='none';

  // Show real-world gallery card on success
  const galleryItem = success ? GALLERY.find(g => g.world === currentWorld && g.level === currentLevel) : null;
  const resultHintEl = document.getElementById('resultHint');
  if (galleryItem && success) {
    resultHintEl.innerHTML = `ğŸŒ <b>Real World:</b> ${galleryItem.emoji} <b>${galleryItem.name}</b> (${galleryItem.loc}) â€” ${galleryItem.fact}`;
    resultHintEl.style.color = '#64B5F6';
  } else {
    resultHintEl.style.color = '#90A4AE';
  }

  const hk = starKey(currentWorld,currentLevel);
  const attempts = levelAttempts[hk]||0;
  if (!success) {
    document.getElementById('resultHint').textContent =
      lastHint[hk] ? `ğŸ’¡ Remember: ${lastHint[hk]}` : "Don't worry â€” even real engineers test many designs! Try again.";
    document.getElementById('resultHint').style.color = '#90A4AE';
  }

  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const retry = document.createElement('button');
  retry.className = 'btn btn-md '+(success?'btn-blue':'btn-orange');
  retry.textContent = success?'Try Again':'Try Again ğŸ”„';
  retry.onclick = () => startGame();
  btns.appendChild(retry);

  // What-If panel
  const wifPanel = document.getElementById('whatIfPanel');
  const eTypeR = (w.testType==='castle') ? getLevel().castlePhase : w.testType;
  if (success && eTypeR !== 'circuit' && eTypeR !== 'arch' && eTypeR !== 'flight') {
    wifPanel.style.display = 'block';
    document.getElementById('wifGravity').value = 100;
    document.getElementById('wifWeight').value = 100;
    document.getElementById('wifWind').value = 0;
    document.getElementById('wifGravVal').textContent = '100%';
    document.getElementById('wifWeightVal').textContent = '100%';
    document.getElementById('wifWindVal').textContent = '0%';
  } else {
    wifPanel.style.display = 'none';
  }

  if (success && currentLevel < w.levels.length-1) {
    const next = document.createElement('button');
    next.className = 'btn btn-md btn-green';
    next.textContent = 'Next Level â†’';
    next.onclick = () => { currentLevel++; showIntro(currentLevel); };
    btns.appendChild(next);
  }
  if (success) {
    const shareBtn = document.createElement('button');
    shareBtn.className = 'btn btn-md btn-pink';
    shareBtn.textContent = 'ğŸ“¸ Share Design';
    shareBtn.onclick = () => shareDesign();
    btns.appendChild(shareBtn);
  }

  if (success && currentLevel === w.levels.length-1) {
    const done = document.createElement('button');
    done.className = 'btn btn-md btn-purple';
    done.textContent = 'More Worlds! ğŸŒ';
    done.onclick = () => showScreen('worlds');
    btns.appendChild(done);
  }

  if (success) {
    confetti.launch(stars);
    setTimeout(() => confetti.launch(stars), 400);
    if (stars === 3) setTimeout(() => confetti.launch(3), 800);
    const newBadge = checkBadges();
    if (newBadge) {
      sfx.play('badge');
      setTimeout(() => {
        const hint = document.getElementById('resultHint');
        hint.innerHTML = `ğŸ† <b>NEW BADGE: ${newBadge.emoji} ${newBadge.name}!</b> â€” ${newBadge.desc}<br>` + hint.innerHTML;
        hint.style.color = '#FF8F00';
      }, 600);
    }
  }

  showScreen('result');
}

// â”€â”€ CO-OP BUILD MODE â”€â”€
let coopState = null; // { turn:1|2, beamsP1:0, beamsP2:0 }

function startCoOp() {
  // Pick a random level (bridges or towers, not arches)
  const worldIdx = Math.floor(Math.random() * 2);
  const levelIdx = Math.floor(Math.random() * Math.min(3, WORLD_DATA[worldIdx].levels.length));
  currentWorld = worldIdx;
  currentLevel = levelIdx;
  coopState = { turn: 1, beamsP1: 0, beamsP2: 0 };
  window._isDailyChallenge = false; window._dailyLevel = null;
  h2hState = null;
  showPlayerBanner('ğŸ‘· Player 1 â€” Place a beam!', 'p1');
  startGame();
}

function coopAfterBeamPlaced() {
  if (!coopState) return;
  if (coopState.turn === 1) {
    coopState.beamsP1++;
    coopState.turn = 2;
    showPlayerBanner(`ğŸ€ Player 2 â€” Your turn! (P1: ${coopState.beamsP1} | P2: ${coopState.beamsP2})`, 'p2');
  } else {
    coopState.beamsP2++;
    coopState.turn = 1;
    showPlayerBanner(`ğŸ‘· Player 1 â€” Your turn! (P1: ${coopState.beamsP1} | P2: ${coopState.beamsP2})`, 'p1');
  }
}

// â”€â”€ HEAD-TO-HEAD MODE â”€â”€
let h2hState = null; // { phase:'p1build'|'p1test'|'p2build'|'p2test'|'results', p1beams:[], p1result:null, p2result:null }

function startH2H() {
  // Pick a random bridge level for fairness
  const worldIdx = 0; // bridges
  const levelIdx = Math.floor(Math.random() * Math.min(3, WORLD_DATA[worldIdx].levels.length));
  currentWorld = worldIdx;
  currentLevel = levelIdx;
  h2hState = { phase: 'p1build', p1beams: [], p1result: null, p2result: null, worldIdx, levelIdx };
  window._isDailyChallenge = false; window._dailyLevel = null;
  showPlayerBanner('ğŸ‘· Player 1 â€” Build!', 'p1');
  startGame();
}

function showPlayerBanner(text, pClass) {
  const banner = document.getElementById('playerBanner');
  banner.textContent = text;
  banner.className = 'player-banner active ' + pClass;
}

function hidePlayerBanner() {
  document.getElementById('playerBanner').className = 'player-banner';
}

function showH2HPassDevice() {
  const el = document.getElementById('result');
  el.className = 'screen active success';
  document.getElementById('resultEmoji').textContent = 'ğŸ”„';
  const title = document.getElementById('resultTitle');
  title.textContent = 'PASS THE DEVICE!';
  title.className = 'result-title win';
  title.style.color = '#E91E63';
  document.getElementById('resultStars').innerHTML = '';
  document.getElementById('principleCard').style.display = 'none';
  document.getElementById('whatIfPanel').style.display = 'none';
  const p1 = h2hState.p1result;
  document.getElementById('resultHint').innerHTML = `Player 1: ${p1.success ? 'âœ… Success' : 'âŒ Failed'} (${p1.beams} beams)<br>Now hand the device to <b>Player 2</b>!`;
  document.getElementById('resultHint').style.color = '#B0BEC5';
  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const goBtn = document.createElement('button');
  goBtn.className = 'btn btn-lg btn-pink';
  goBtn.textContent = "Player 2's Turn! ğŸ®";
  goBtn.onclick = () => {
    showPlayerBanner('ğŸ€ Player 2 â€” Build!', 'p2');
    currentWorld = h2hState.worldIdx;
    currentLevel = h2hState.levelIdx;
    startGame();
  };
  btns.appendChild(goBtn);
  showScreen('result');
}

function showH2HResults() {
  hidePlayerBanner();
  const p1 = h2hState.p1result, p2 = h2hState.p2result;
  let winner;
  if (p1.success && !p2.success) winner = 1;
  else if (!p1.success && p2.success) winner = 2;
  else if (p1.success && p2.success) winner = p1.beams <= p2.beams ? 1 : 2;
  else winner = 0; // tie (both failed)

  const el = document.getElementById('result');
  el.className = 'screen active success';
  document.getElementById('resultEmoji').textContent = winner === 0 ? 'ğŸ¤' : 'ğŸ†';
  const title = document.getElementById('resultTitle');
  title.textContent = winner === 0 ? "IT'S A TIE!" : `PLAYER ${winner} WINS!`;
  title.className = 'result-title win';
  document.getElementById('resultStars').innerHTML = '';
  document.getElementById('principleCard').style.display = 'none';
  document.getElementById('whatIfPanel').style.display = 'none';
  document.getElementById('resultHint').innerHTML =
    `ğŸ‘· P1: ${p1.success?'âœ…':'âŒ'} ${p1.beams} beams | ğŸ€ P2: ${p2.success?'âœ…':'âŒ'} ${p2.beams} beams`;
  document.getElementById('resultHint').style.color = '#B0BEC5';

  if (winner > 0) { confetti.launch(3); setTimeout(() => confetti.launch(3), 400); sfx.play('success'); }
  else sfx.play('fail');

  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const again = document.createElement('button');
  again.className = 'btn btn-md btn-red';
  again.textContent = 'âš”ï¸ Rematch!';
  again.onclick = () => startH2H();
  btns.appendChild(again);
  const menu = document.createElement('button');
  menu.className = 'btn btn-md btn-gray';
  menu.textContent = 'Menu';
  menu.onclick = () => { h2hState = null; showScreen('menu'); };
  btns.appendChild(menu);
  showScreen('result');
  h2hState = null;
}

// â”€â”€ SHARE DESIGN â”€â”€
function shareDesign() {
  if (!canvas) return;
  // Draw a title on a temporary canvas
  const share = document.createElement('canvas');
  share.width = canvas.width;
  share.height = canvas.height + 60;
  const sctx = share.getContext('2d');
  // Header
  sctx.fillStyle = '#1a237e';
  sctx.fillRect(0, 0, share.width, 60);
  sctx.fillStyle = '#fff';
  sctx.font = 'bold 22px sans-serif';
  sctx.textAlign = 'center';
  sctx.textBaseline = 'middle';
  const l = getLevel();
  sctx.fillText(`ğŸ—ï¸ Build Lab â€” ${l.name}`, share.width / 2, 30);
  // Game canvas
  sctx.drawImage(canvas, 0, 60);
  // Convert and share/download
  share.toBlob(blob => {
    if (!blob) return;
    const file = new File([blob], 'my-build.png', { type: 'image/png' });
    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
      navigator.share({ title: 'My Build Lab Design', text: `Check out my ${l.name} design!`, files: [file] }).catch(() => {});
    } else {
      // Fallback: download
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'my-build.png';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  }, 'image/png');
}

// â”€â”€ WHAT-IF MODE â”€â”€
let whatIfOverrides = null;

function runWhatIf() {
  const gravMult = parseInt(document.getElementById('wifGravity').value) / 100;
  const weightMult = parseInt(document.getElementById('wifWeight').value) / 100;
  const windPct = parseInt(document.getElementById('wifWind').value) / 100;
  whatIfOverrides = { gravMult, weightMult, windPct };
  // Restart the game with same beams but modified physics
  showScreen('game');
  initCanvas();
  updateMaterialBtns();
  updateGameUI();
  document.getElementById('helpOverlay').style.display = 'none';
  helpVisible = false;
  // Immediately start test with overrides
  startTest();
}

// â”€â”€ REAL-WORLD GALLERY â”€â”€
const GALLERY = [
  { world:0, level:0, emoji:'ğŸŒ‰', name:'Ponte Vecchio', loc:'Florence, Italy', fact:'Built in 1345, this medieval bridge has shops built right on top of it! It survived World War II.' },
  { world:0, level:1, emoji:'ğŸ—¼', name:'Eiffel Tower', loc:'Paris, France', fact:'Made of 18,038 iron pieces joined by 2.5 million rivets, all connected in triangles for strength.' },
  { world:0, level:2, emoji:'ğŸ›ï¸', name:'Pont du Gard', loc:'France', fact:'A Roman aqueduct bridge with 3 tiers of arches, built 2,000 years ago without mortar!' },
  { world:0, level:3, emoji:'ğŸŒ', name:'Golden Gate Bridge', loc:'San Francisco, USA', fact:'Its cables contain 80,000 miles of steel wire â€” enough to wrap around Earth 3 times!' },
  { world:0, level:4, emoji:'ğŸ”ï¸', name:'Millau Viaduct', loc:'France', fact:'The tallest bridge in the world at 1,125 feet â€” taller than the Eiffel Tower!' },
  { world:1, level:0, emoji:'ğŸ”º', name:'Great Pyramid of Giza', loc:'Egypt', fact:'Was the tallest structure for 3,800 years. Its wide base is the key to its stability.' },
  { world:1, level:1, emoji:'ğŸ—¼', name:'Tokyo Skytree', loc:'Japan', fact:'At 2,080 feet, it uses a central core and triangular cross-bracing to resist earthquakes.' },
  { world:1, level:2, emoji:'ğŸ’¨', name:'Taipei 101', loc:'Taiwan', fact:'Has a 728-ton pendulum that swings to counteract wind! Reduces swaying by 40%.' },
  { world:1, level:3, emoji:'ğŸ™ï¸', name:'Burj Khalifa', loc:'Dubai, UAE', fact:'At 2,717 feet, its Y-shaped floor plan helps resist wind forces from all directions.' },
  { world:2, level:0, emoji:'ğŸ›ï¸', name:'The Colosseum', loc:'Rome, Italy', fact:'Built with 80 arched entrances, it could seat 50,000 spectators nearly 2,000 years ago.' },
  { world:2, level:1, emoji:'ğŸº', name:'Aqueduct of Segovia', loc:'Spain', fact:'163 arches made of granite blocks with no mortar â€” gravity and precise cutting hold it together!' },
  { world:2, level:2, emoji:'â›ª', name:'Notre-Dame Cathedral', loc:'Paris, France', fact:'Its pointed Gothic arches allowed builders to reach unprecedented heights in the 12th century.' },
  { world:2, level:3, emoji:'ğŸŒŠ', name:'Roman Aqueducts', loc:'Roman Empire', fact:'Stretched over 250 miles total, carrying 1 billion liters of water daily to Rome!' },
  { world:3, level:0, emoji:'ğŸ’¡', name:"Edison's Lab", loc:'New Jersey, USA', fact:'Thomas Edison tested over 3,000 designs before perfecting the incandescent light bulb.' },
  { world:3, level:1, emoji:'ğŸ”Œ', name:'Home Wiring', loc:'Everywhere', fact:'Your home uses parallel circuits so each device gets full voltage independently.' },
  { world:3, level:2, emoji:'ğŸ§©', name:'Circuit Boards', loc:'Inside Electronics', fact:'Modern CPUs have billions of transistors routed around obstacles on chips smaller than a fingernail.' },
  { world:3, level:3, emoji:'ğŸŒ', name:'US Power Grid', loc:'USA', fact:'The largest machine ever built: 450,000 miles of transmission lines powering 330 million people.' },
];

function renderGallery() {
  const grid = document.getElementById('galleryGrid');
  grid.innerHTML = '';
  for (const g of GALLERY) {
    const sk = starKey(g.world, g.level);
    const unlocked = (earnedStars[sk] || 0) > 0;
    const card = document.createElement('div');
    card.className = 'gallery-card' + (unlocked ? '' : ' locked');
    card.innerHTML = `
      <div class="gallery-icon">${unlocked ? g.emoji : 'ğŸ”’'}</div>
      <div class="gallery-info">
        <div class="gallery-name">${unlocked ? g.name : '???'}</div>
        <div class="gallery-loc">${unlocked ? g.loc : 'Complete the level to unlock'}</div>
        ${unlocked ? `<div class="gallery-fact">${g.fact}</div>` : ''}
      </div>
    `;
    grid.appendChild(card);
  }
}

// â”€â”€ DAILY CHALLENGE â”€â”€
function seededRandom(seed) {
  let s = seed;
  return function() { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; };
}

function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth()+1) * 100 + d.getDate();
}

function startDailyChallenge() {
  const seed = getDailySeed();
  const rng = seededRandom(seed);
  const worldIdx = Math.floor(rng() * 2); // bridges, towers (not arches/circuits for daily)
  const w = WORLD_DATA[worldIdx];

  // Pick a random existing level as template and modify it
  const templateIdx = Math.floor(rng() * w.levels.length);
  const template = w.levels[templateIdx];

  // Create modified daily level
  const dailyLevel = JSON.parse(JSON.stringify(template));
  dailyLevel.name = "Daily Challenge";
  dailyLevel.subtitle = new Date().toLocaleDateString('en-US', {month:'short', day:'numeric'});
  dailyLevel.emoji = "ğŸ“…";
  dailyLevel.description = `Today's challenge: a ${w.name.toLowerCase()} puzzle! Can you beat it?`;
  dailyLevel.tip = template.tip;
  dailyLevel.fact = template.fact;

  // Modify difficulty slightly using seed
  if (dailyLevel.vehicleWeight) dailyLevel.vehicleWeight = +(dailyLevel.vehicleWeight * (0.8 + rng() * 0.6)).toFixed(1);
  if (dailyLevel.testWeight) dailyLevel.testWeight = +(dailyLevel.testWeight * (0.8 + rng() * 0.6)).toFixed(1);
  dailyLevel.par = Math.max(5, dailyLevel.par + Math.floor(rng() * 5 - 2));

  // Set as current level
  currentWorld = worldIdx;
  // Temporarily inject daily level
  const origLevels = w.levels;
  w.levels = [dailyLevel];
  currentLevel = 0;
  showIntro(0);
  // Restore after intro is shown
  setTimeout(() => { w.levels = origLevels; }, 100);
  // Override startGame to use daily level
  window._dailyLevel = dailyLevel;
  window._dailyWorld = worldIdx;
  window._isDailyChallenge = true;
}

// â”€â”€ CONSTRUCTION BUDDY â”€â”€
const buddy = {
  timer: null,
  messages: {
    start: ["Let's build something awesome!", "Ready to engineer?", "I believe in you!", "Time to construct!"],
    fewBeams: ["Good start! Keep connecting dots!", "Nice! Try adding more beams.", "You're getting the hang of it!"],
    triangles: ["Try adding diagonal beams for triangles!", "Triangles are super strong!", "A diagonal here would help!"],
    arches: ["Tap the ghost stones to place them!", "Don't forget the keystone â€” it locks everything!", "Each stone leans on the next â€” fill every gap!"],
    towers: ["Build wide at the bottom for stability!", "Add X-bracing to stop it swaying!", "A wider base makes a stronger tower!"],
    manyBeams: ["Looking solid! Ready to test?", "Great structure! Let's see if it holds!", "That's some fine engineering!"],
    testing: ["Here we go... ğŸ¤", "Fingers crossed!", "Let's see how it holds!"],
    break: ["Oops! That beam snapped!", "Don't worry, we can fix this!", "Try reinforcing that spot!"],
    circuit: ["Connect the battery to all bulbs!", "Electricity needs a path!", "Wire it up! âš¡"],
    castle: ["Build your mighty castle!", "Every castle needs a strong foundation!", "Think like a medieval engineer! ğŸ°"],
    flying: ["Angle those beams upward for lift! âœˆï¸", "Wider wings = more lift!", "Keep it light â€” every beam adds weight!"]
  },
  say(category) {
    const msgs = this.messages[category];
    if (!msgs) return;
    const msg = msgs[Math.floor(Math.random() * msgs.length)];
    const bubble = document.getElementById('buddyBubble');
    if (bubble) { bubble.textContent = msg; bubble.style.animation = 'none'; bubble.offsetHeight; bubble.style.animation = 'bubbleFade .3s ease-out'; }
  },
  autoTip() {
    if (isTesting) return;
    const w = getWorld();
    const beamCount = gameBeams.length;
    if (beamCount === 0) this.say('start');
    else if (w.testType === 'circuit') this.say('circuit');
    else if (beamCount < 3) this.say('fewBeams');
    else if (w.id === 'arches' || (w.id === 'castle' && getLevel().castlePhase === 'arch')) { if (archState && archState.placed.size < archState.shapes.length/2) this.say('arches'); }
    else if (w.id === 'castle') this.say('castle');
    else if (w.id === 'flying') this.say('flying');
    else if (w.id === 'towers' && beamCount < 6) this.say('towers');
    else if (beamCount < 6) this.say('triangles');
    else this.say('manyBeams');
  },
  startTips() {
    this.say('start');
    if (this.timer) clearInterval(this.timer);
    this.timer = setInterval(() => this.autoTip(), 12000);
  },
  stop() { if (this.timer) { clearInterval(this.timer); this.timer = null; } }
};

// â”€â”€ BUILDER BADGES â”€â”€
const BADGES = [
  { id:'first_build', emoji:'ğŸ”¨', name:'First Build', desc:'Complete your first level', check:()=>getTotalStars()>=1 },
  { id:'bridge_master', emoji:'ğŸŒ‰', name:'Bridge Master', desc:'Earn all bridge stars', check:()=>getWorldStars(0)>=15 },
  { id:'tower_master', emoji:'ğŸ°', name:'Tower King', desc:'Earn all tower stars', check:()=>getWorldStars(1)>=12 },
  { id:'arch_master', emoji:'ğŸ›ï¸', name:'Arch Expert', desc:'Earn all arch stars', check:()=>getWorldStars(2)>=12 },
  { id:'circuit_master', emoji:'âš¡', name:'Circuit Whiz', desc:'Earn all circuit stars', check:()=>getWorldStars(3)>=12 },
  { id:'castle_master', emoji:'ğŸ°', name:'Castle Lord', desc:'Earn all castle stars', check:()=>getWorldStars(4)>=12 },
  { id:'flight_master', emoji:'âœˆï¸', name:'Ace Pilot', desc:'Earn all flying stars', check:()=>getWorldStars(5)>=12 },
  { id:'star_collector', emoji:'â­', name:'Star Collector', desc:'Earn 20 total stars', check:()=>getTotalStars()>=20 },
  { id:'perfectionist', emoji:'ğŸ’', name:'Perfectionist', desc:'Get 3 stars on 5 levels', check:()=>Object.values(earnedStars).filter(s=>s===3).length>=5 },
  { id:'engineer', emoji:'ğŸ“', name:'Engineer', desc:'Complete all 6 worlds', check:()=>WORLD_DATA.every((_,i)=>getWorldStars(i)>0 && WORLD_DATA[i].levels.every((_,j)=>(earnedStars[starKey(i,j)]||0)>0)) },
  { id:'persistent', emoji:'ğŸ’ª', name:'Never Give Up', desc:'Retry a level 5+ times', check:()=>Object.values(levelAttempts).some(a=>a>=5) },
  { id:'speedster', emoji:'ğŸš€', name:'Speedster', desc:'Beat a level under par', check:()=>{ for(let wi=0;wi<WORLD_DATA.length;wi++) for(let li=0;li<WORLD_DATA[wi].levels.length;li++) if((earnedStars[starKey(wi,li)]||0)===3) return true; return false; }},
  { id:'all_stars', emoji:'ğŸŒŸ', name:'Superstar', desc:'Earn every single star', check:()=>getTotalStars()>=75 },
  { id:'explorer', emoji:'ğŸ—ºï¸', name:'Explorer', desc:'Try all 6 worlds', check:()=>WORLD_DATA.every((_,i)=>getWorldStars(i)>0) },
];
let earnedBadges = {};

function loadBadges() {
  try { earnedBadges = JSON.parse(localStorage.getItem('buildlab_badges')) || {}; } catch(e) { earnedBadges = {}; }
}
function saveBadges() {
  try { localStorage.setItem('buildlab_badges', JSON.stringify(earnedBadges)); } catch(e) {}
}

function checkBadges() {
  let newBadge = null;
  for (const b of BADGES) {
    if (!earnedBadges[b.id] && b.check()) {
      earnedBadges[b.id] = Date.now();
      newBadge = b;
    }
  }
  saveBadges();
  return newBadge;
}

function renderBadges() {
  const grid = document.getElementById('badgesGrid');
  grid.innerHTML = '';
  const earned = BADGES.filter(b => earnedBadges[b.id]).length;
  document.getElementById('badgeCount').textContent = `${earned} / ${BADGES.length}`;
  for (const b of BADGES) {
    const card = document.createElement('div');
    const isEarned = !!earnedBadges[b.id];
    card.className = 'badge-card ' + (isEarned ? 'earned' : 'locked');
    card.innerHTML = `
      <div class="badge-emoji">${isEarned ? b.emoji : 'ğŸ”’'}</div>
      <div class="badge-name">${b.name}</div>
      <div class="badge-desc">${b.desc}</div>
    `;
    grid.appendChild(card);
  }
}

// â”€â”€ SOUND ENGINE (Web Audio API) â”€â”€
const sfx = {
  ctx: null, unlocked: false, muted: false,
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (this.ctx.state === 'suspended') this.ctx.resume();
    this.unlocked = true;
  },
  unlock() {
    if (this.unlocked) return;
    this.init();
  },
  play(type) {
    if (this.muted || !this.ctx) return;
    try { this[type](); } catch(e) {}
  },
  place() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(440, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(880, this.ctx.currentTime + 0.08);
    g.gain.setValueAtTime(0.15, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
    o.start(); o.stop(this.ctx.currentTime + 0.15);
  },
  remove() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(600, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.1);
    g.gain.setValueAtTime(0.12, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);
    o.start(); o.stop(this.ctx.currentTime + 0.12);
  },
  breakBeam() {
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
    const s = this.ctx.createBufferSource(), g = this.ctx.createGain();
    s.buffer = buf; s.connect(g); g.connect(this.ctx.destination);
    g.gain.setValueAtTime(0.2, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    s.start();
  },
  success() {
    const notes = [523, 659, 784, 1047];
    notes.forEach((freq, i) => {
      const o = this.ctx.createOscillator(), g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.type = 'sine'; o.frequency.value = freq;
      const t = this.ctx.currentTime + i * 0.15;
      g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.15, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
      o.start(t); o.stop(t + 0.4);
    });
  },
  fail() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.5);
    g.gain.setValueAtTime(0.12, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    o.start(); o.stop(this.ctx.currentTime + 0.5);
  },
  badge() {
    const notes = [784, 988, 1175, 1319, 1568];
    notes.forEach((freq, i) => {
      const o = this.ctx.createOscillator(), g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.type = 'triangle'; o.frequency.value = freq;
      const t = this.ctx.currentTime + i * 0.1;
      g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.12, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      o.start(t); o.stop(t + 0.3);
    });
  }
};

// â”€â”€ CONFETTI CELEBRATION â”€â”€
const confetti = {
  canvas: null, ctx: null, particles: [], animId: null,
  colors: ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#FF922B','#CC5DE8','#20C997','#FF6B9D'],
  init() {
    this.canvas = document.getElementById('confettiCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },
  resize() {
    if (!this.canvas) return;
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  },
  launch(intensity) {
    const count = intensity === 3 ? 150 : intensity === 2 ? 100 : 60;
    for (let i = 0; i < count; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: -20 - Math.random() * 200,
        vx: (Math.random() - 0.5) * 8,
        vy: Math.random() * 3 + 2,
        size: Math.random() * 8 + 4,
        color: this.colors[Math.floor(Math.random() * this.colors.length)],
        rotation: Math.random() * 360,
        rotSpeed: (Math.random() - 0.5) * 12,
        shape: Math.random() > 0.5 ? 'rect' : 'circle',
        life: 1,
        decay: 0.003 + Math.random() * 0.004,
        wobble: Math.random() * 10,
        wobbleSpeed: 0.03 + Math.random() * 0.05
      });
    }
    if (!this.animId) this.animate();
  },
  animate() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += p.vx + Math.sin(p.wobble) * 0.5;
      p.y += p.vy;
      p.vy += 0.04;
      p.vx *= 0.99;
      p.rotation += p.rotSpeed;
      p.wobble += p.wobbleSpeed;
      p.life -= p.decay;
      if (p.life <= 0 || p.y > this.canvas.height + 20) {
        this.particles.splice(i, 1); continue;
      }
      this.ctx.save();
      this.ctx.translate(p.x, p.y);
      this.ctx.rotate(p.rotation * Math.PI / 180);
      this.ctx.globalAlpha = p.life;
      this.ctx.fillStyle = p.color;
      if (p.shape === 'rect') {
        this.ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
      } else {
        this.ctx.beginPath();
        this.ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
        this.ctx.fill();
      }
      this.ctx.restore();
    }
    if (this.particles.length > 0) {
      this.animId = requestAnimationFrame(() => this.animate());
    } else {
      this.animId = null;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }
};

// â”€â”€ BG ICONS â”€â”€
function setupMenuBG() {
  const icons=['âš™ï¸','ğŸ”§','ğŸ”©','ğŸ—ï¸','ğŸ“','ğŸ”¨','ğŸªµ','âš¡','ğŸ›ï¸','ğŸŒ‰'];
  const container = document.getElementById('bgIcons');
  for (let i=0;i<18;i++) {
    const span = document.createElement('span');
    span.className='bg-icon';
    span.style.left=(i*37%100)+'%';
    span.style.top=(i*53%100)+'%';
    span.style.fontSize=[22,30,18,26,24,20][i%6]+'px';
    span.style.transform=`rotate(${i*30}deg)`;
    span.textContent=icons[i%icons.length];
    container.appendChild(span);
  }
}

// â”€â”€ RESIZE â”€â”€
window.addEventListener('resize', () => {
  if (document.getElementById('game').classList.contains('active') && canvas) {
    resizeCanvas(); drawGame();
  }
});

// â”€â”€ INIT â”€â”€
document.addEventListener('DOMContentLoaded', () => {
  loadProgress();
  loadBadges();
  setupMenuBG();
  updateMenuStars();
  confetti.init();
  document.addEventListener('touchstart', e => { sfx.unlock(); if(e.touches.length>1)e.preventDefault(); },{passive:false});
  document.addEventListener('mousedown', () => sfx.unlock(), {once:true});
  let lastTouch=0;
  document.addEventListener('touchend', e => { const now=Date.now(); if(now-lastTouch<=300)e.preventDefault(); lastTouch=now; },false);
});
</script>
</body>
</html>
