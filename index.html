<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Build Lab">
<title>Build Lab â€” Engineering Adventure</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html, body { width:100%; height:100%; overflow:hidden; font-family:'Segoe UI',system-ui,-apple-system,sans-serif; background:#0a0e27; }
  body { display:flex; justify-content:center; align-items:center; }
  #app { width:100%; max-width:960px; height:100dvh; height:100vh; position:relative; overflow:hidden; }
  @supports (height: 100dvh) { #app { height:100dvh; } }

  .screen { position:absolute; inset:0; display:none; flex-direction:column; overflow-y:auto; -webkit-overflow-scrolling:touch; }
  .screen.active { display:flex; animation:screenIn .35s ease-out; }
  @keyframes screenIn { from{opacity:0;transform:translateY(12px)} to{opacity:1;transform:translateY(0)} }
  .btn {
    border:none; border-radius:16px; font-weight:700; cursor:pointer; letter-spacing:.5px;
    transition:transform .15s,box-shadow .15s,filter .15s; font-family:inherit; text-align:center;
    position:relative; overflow:hidden;
  }
  .btn::after {
    content:''; position:absolute; inset:0; background:linear-gradient(180deg,rgba(255,255,255,.15) 0%,transparent 60%);
    pointer-events:none; border-radius:inherit;
  }
  .btn:active { transform:scale(.94); filter:brightness(1.1); }
  .btn-lg { padding:18px 50px; font-size:22px; border-radius:25px; }
  .btn-md { padding:12px 28px; font-size:17px; }
  .btn-sm { padding:8px 16px; font-size:13px; border-radius:11px; }
  .btn-orange { background:linear-gradient(135deg,#FF9800,#F57C00); color:#fff; box-shadow:0 4px 18px #FF980055,0 0 30px #FF980022; }
  .btn-blue { background:linear-gradient(135deg,#42A5F5,#1565C0); color:#fff; box-shadow:0 4px 18px #2196F355,0 0 30px #2196F322; }
  .btn-green { background:linear-gradient(135deg,#66BB6A,#2E7D32); color:#fff; box-shadow:0 4px 18px #4CAF5055,0 0 30px #4CAF5022; }
  .btn-red { background:linear-gradient(135deg,#EF5350,#C62828); color:#fff; box-shadow:0 4px 18px #F4433655,0 0 30px #F4433622; }
  .btn-gray { background:linear-gradient(135deg,#90A4AE,#546E7A); color:#fff; box-shadow:0 4px 12px #78909C33; }
  .btn-purple { background:linear-gradient(135deg,#B388FF,#651FFF); color:#fff; box-shadow:0 4px 18px #7C4DFF55,0 0 30px #7C4DFF22; }
  .btn-teal { background:linear-gradient(135deg,#26A69A,#00695C); color:#fff; box-shadow:0 4px 18px #00968855,0 0 30px #00968822; }
  .btn-pink { background:linear-gradient(135deg,#F06292,#AD1457); color:#fff; box-shadow:0 4px 18px #E91E6355,0 0 30px #E91E6322; }
  .stars { display:flex; gap:4px; }
  .star { font-size:28px; transition:transform .3s; }
  .star.on { color:#FFD700; text-shadow:0 2px 12px rgba(255,215,0,.7),0 0 20px rgba(255,215,0,.3); transform:scale(1.15); }
  .star.off { color:#455A64; transform:scale(.85); }

  #menu {
    background:linear-gradient(135deg,#0a0e27 0%,#1a237e 30%,#283593 60%,#1565C0 100%);
    background-size:300% 300%; animation:menuBG 8s ease infinite;
    align-items:center; justify-content:center; gap:14px; padding:24px 30px; text-align:center;
  }
  @keyframes menuBG { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
  #menu .bg-icons { position:absolute; inset:0; pointer-events:none; overflow:hidden; }
  #menu .bg-icon { position:absolute; opacity:.08; animation:floatIcon 6s ease-in-out infinite; }
  @keyframes floatIcon { 0%,100%{transform:translateY(0) rotate(0deg)} 50%{transform:translateY(-12px) rotate(8deg)} }
  #menu h1 {
    font-size:min(14vw,60px); font-weight:900; color:#fff;
    text-shadow:0 4px 20px rgba(0,0,0,.4),0 0 40px rgba(66,165,245,.4),0 0 80px rgba(66,165,245,.15);
    letter-spacing:4px; z-index:1;
  }
  #menu .subtitle { font-size:20px; color:#90CAF9; font-weight:600; z-index:1; letter-spacing:2px; }
  #menu .star-count { color:#FFD700; font-size:20px; font-weight:700; z-index:1; text-shadow:0 0 12px rgba(255,215,0,.4); }
  #menu .age-note { color:#5C6BC0; font-size:13px; z-index:1; }

  #worlds { background:linear-gradient(160deg,#0d1b2a 0%,#1b2838 40%,#1a3a4a 100%); padding:24px; gap:20px; }
  .worlds-grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; max-width:560px; margin:0 auto; width:100%; }
  .world-card {
    padding:22px 16px; border-radius:22px; border:2px solid rgba(255,255,255,.1); text-align:center; cursor:pointer;
    transition:transform .2s,box-shadow .2s; position:relative; font-family:inherit; color:#fff;
    overflow:hidden;
  }
  .world-card::before {
    content:''; position:absolute; inset:0;
    background:radial-gradient(circle at 30% 20%,rgba(255,255,255,.12),transparent 60%);
    pointer-events:none;
  }
  .world-card:active { transform:scale(.95); }
  .world-card .emoji { font-size:48px; margin-bottom:8px; filter:drop-shadow(0 4px 8px rgba(0,0,0,.3)); animation:cardEmoji 3s ease-in-out infinite; }
  @keyframes cardEmoji { 0%,100%{transform:scale(1) rotate(0)} 50%{transform:scale(1.08) rotate(3deg)} }
  .world-card .wname { font-size:20px; font-weight:800; margin-bottom:4px; text-shadow:0 2px 8px rgba(0,0,0,.3); }
  .world-card .wdesc { font-size:12px; opacity:.8; margin-bottom:8px; }
  .world-card .wstars { font-size:13px; opacity:.9; text-shadow:0 0 8px rgba(255,215,0,.3); }

  #levels { background:linear-gradient(160deg,#0d1b2a 0%,#1b2838 40%,#1a3a4a 100%); padding:24px; gap:14px; }
  .level-btn {
    display:flex; align-items:center; gap:14px; padding:14px 18px; border-radius:16px;
    border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.06); backdrop-filter:blur(8px);
    cursor:pointer; text-align:left; font-family:inherit;
    box-shadow:0 4px 16px rgba(0,0,0,.2); transition:transform .2s,box-shadow .2s; width:100%;
  }
  .level-btn:active { transform:scale(.97); box-shadow:0 2px 8px rgba(0,0,0,.3); }
  .level-btn.locked { opacity:.4; cursor:default; }
  .level-num {
    width:46px; height:46px; border-radius:13px; display:flex; align-items:center; justify-content:center;
    font-size:20px; font-weight:900; color:#fff; flex-shrink:0;
  }
  .level-info { flex:1; }
  .level-name { font-size:16px; font-weight:700; color:#E0E0E0; }
  .level-sub { font-size:12px; color:#90A4AE; }

  #intro { background:linear-gradient(160deg,#0a0e27 0%,#1a237e 50%,#0d47a1 100%); align-items:center; justify-content:center; padding:24px; gap:14px; text-align:center; }
  .intro-emoji { font-size:56px; animation:introEmoji 2s ease-in-out infinite; filter:drop-shadow(0 4px 12px rgba(0,0,0,.4)); }
  @keyframes introEmoji { 0%,100%{transform:scale(1) rotate(-3deg)} 50%{transform:scale(1.1) rotate(3deg)} }
  .intro-title { font-size:min(8vw,30px); font-weight:800; color:#fff; text-shadow:0 2px 12px rgba(0,0,0,.3); }
  .intro-desc { font-size:15px; color:#B0BEC5; max-width:440px; line-height:1.5; }
  .tip-card, .fact-card { border-radius:16px; padding:14px 20px; max-width:440px; width:100%; text-align:left; backdrop-filter:blur(8px); }
  .tip-card { background:rgba(255,152,0,.12); border:1px solid rgba(255,152,0,.3); }
  .tip-card .label { font-size:13px; font-weight:700; color:#FFB74D; margin-bottom:5px; }
  .tip-card .body { font-size:14px; color:#FFE0B2; line-height:1.5; }
  .fact-card { background:rgba(33,150,243,.1); border:1px solid rgba(33,150,243,.25); }
  .fact-card .label { font-size:13px; font-weight:700; color:#64B5F6; margin-bottom:5px; }
  .fact-card .body { font-size:14px; color:#BBDEFB; line-height:1.5; }

  #game { background:linear-gradient(160deg,#0d1b2a,#172a3a); padding:6px 8px; gap:4px; padding-bottom:max(6px, env(safe-area-inset-bottom)); }
  .game-topbar {
    display:flex; align-items:center; justify-content:space-between; padding:6px 10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1); border-radius:12px;
    backdrop-filter:blur(8px); flex-shrink:0;
  }
  .game-topbar .title { font-size:14px; font-weight:800; color:#E0E0E0; }
  .game-topbar .meta { font-size:10px; color:#90A4AE; }
  .canvas-wrap {
    display:flex; justify-content:center; border-radius:14px; overflow:hidden;
    box-shadow:0 4px 24px rgba(0,0,0,.3),0 0 40px rgba(33,150,243,.06); flex:1; min-height:0; position:relative;
    border:1px solid rgba(255,255,255,.06);
  }
  .canvas-wrap canvas { width:100%; height:100%; touch-action:none; cursor:pointer; display:block; }
  .game-bottombar {
    display:flex; align-items:center; justify-content:space-between; padding:8px 10px;
    background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.1); border-radius:14px;
    backdrop-filter:blur(8px); flex-shrink:0;
  }
  .mat-btn {
    padding:8px 14px; border-radius:11px; border:2px solid rgba(255,255,255,.15);
    cursor:pointer; display:flex; align-items:center; gap:5px;
    font-size:13px; font-weight:700; color:#E0E0E0; background:rgba(255,255,255,.08); font-family:inherit;
    transition:all .2s;
  }
  .mat-btn.active { border-color:#42A5F5; background:rgba(33,150,243,.2); color:#fff; box-shadow:0 0 12px rgba(33,150,243,.3); }
  .progress-bar { height:8px; border-radius:4px; background:rgba(255,255,255,.1); overflow:hidden; margin-top:6px; }
  .progress-fill { height:100%; border-radius:4px; background:linear-gradient(90deg,#66BB6A,#42A5F5,#7C4DFF); background-size:200%; animation:progressGlow 2s linear infinite; transition:width .1s; }
  @keyframes progressGlow { 0%{background-position:200% 0} 100%{background-position:0% 0} }

  .help-overlay {
    position:absolute; inset:0; background:rgba(0,0,0,.6); display:flex;
    align-items:center; justify-content:center; z-index:20;
  }
  .help-box {
    background:rgba(0,0,0,.88); color:#fff; border-radius:20px; padding:24px 30px;
    max-width:310px; text-align:center; box-shadow:0 8px 30px rgba(0,0,0,.3);
  }
  .help-box .hicon { font-size:36px; margin-bottom:8px; }
  .help-box h3 { font-size:18px; font-weight:700; margin-bottom:10px; }
  .help-box p { font-size:14px; line-height:1.7; margin-bottom:12px; }

  .failure-overlay {
    position:absolute; inset:0; background:rgba(0,0,0,.75); display:none;
    align-items:center; justify-content:center; z-index:25;
  }
  .failure-overlay.active { display:flex; }
  .failure-box {
    background:linear-gradient(135deg,#2d0a0a,#1a0000); color:#fff; border-radius:20px; padding:24px;
    max-width:340px; text-align:center; border:2px solid #F44336; box-shadow:0 8px 40px rgba(244,67,54,.3);
  }
  .failure-box .ficon { font-size:40px; margin-bottom:8px; }
  .failure-box h3 { font-size:19px; font-weight:800; color:#F44336; margin-bottom:10px; }
  .failure-box .cause { font-size:14px; color:#FFCDD2; line-height:1.6; margin-bottom:14px; }
  .hint-card {
    background:rgba(255,152,0,.15); border:1px solid #FF9800; border-radius:12px;
    padding:12px 16px; margin-bottom:16px; text-align:left;
  }
  .hint-card .hlabel { font-size:11px; font-weight:800; color:#FF9800; margin-bottom:4px; letter-spacing:1px; }
  .hint-card .hbody { font-size:13px; color:#FFE0B2; line-height:1.5; }

  .hint-banner {
    display:none; padding:6px 12px; background:rgba(255,152,0,.12); border-radius:10px; text-align:center;
    border:1px solid rgba(255,152,0,.3); flex-shrink:0; backdrop-filter:blur(8px);
  }
  .hint-banner.active { display:block; }
  .hint-banner .hlabel { font-size:11px; font-weight:700; color:#FFB74D; }
  .hint-banner .htext { font-size:12px; color:#FFE0B2; }

  #result { align-items:center; justify-content:center; padding:24px; gap:12px; text-align:center; }
  #result.success { background:linear-gradient(160deg,#0a1a0a 0%,#0d2818 40%,#1a3a2a 100%); }
  #result.fail { background:linear-gradient(160deg,#1a0a0a 0%,#2d1212 40%,#3a1a1a 100%); }
  .result-emoji { font-size:56px; filter:drop-shadow(0 4px 16px rgba(0,0,0,.4)); }
  .result-title { font-size:min(7vw,30px); font-weight:900; text-shadow:0 2px 12px rgba(0,0,0,.3); }
  .result-title.win { color:#66BB6A; text-shadow:0 0 20px rgba(76,175,80,.4); }
  .result-title.lose { color:#EF5350; text-shadow:0 0 20px rgba(244,67,54,.4); }
  .principle-card { background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:16px 22px; max-width:410px; backdrop-filter:blur(8px); }
  .principle-card .label { font-size:13px; font-weight:700; color:#64B5F6; margin-bottom:5px; }
  .principle-card .body { font-size:15px; color:#CFD8DC; line-height:1.5; }
  .result-hint { font-size:15px; color:#90A4AE; max-width:340px; line-height:1.5; }
  .result-btns { display:flex; gap:12px; margin-top:8px; flex-wrap:wrap; justify-content:center; }
  .back-link { background:none; border:none; color:#5C6BC0; font-size:14px; cursor:pointer; margin-top:6px; font-family:inherit; }
  #confettiCanvas { position:fixed; inset:0; pointer-events:none; z-index:999; }
  #badges { background:linear-gradient(160deg,#0a0e27 0%,#1a1a3e 40%,#2a1a3a 100%); padding:24px; gap:14px; }
  .badges-grid { display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; max-width:520px; margin:0 auto; width:100%; }
  .badge-card {
    padding:16px 10px; border-radius:16px; text-align:center; background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.08); box-shadow:0 3px 12px rgba(0,0,0,.2); transition:transform .15s;
  }
  .badge-card.earned { background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(255,183,77,.1)); border-color:rgba(255,215,0,.3); box-shadow:0 4px 16px rgba(255,215,0,.2),0 0 20px rgba(255,215,0,.08); }
  .badge-card.locked { opacity:.35; }
  .badge-emoji { font-size:36px; margin-bottom:4px; filter:drop-shadow(0 2px 6px rgba(0,0,0,.3)); }
  .badge-name { font-size:12px; font-weight:700; color:#E0E0E0; }
  .badge-desc { font-size:10px; color:#90A4AE; margin-top:2px; }
  #gallery { background:linear-gradient(160deg,#0a0e27 0%,#0d1b2a 40%,#1a2a4a 100%); padding:24px; gap:14px; }
  .gallery-grid { display:flex; flex-direction:column; gap:12px; max-width:520px; margin:0 auto; width:100%; }
  .gallery-card {
    padding:16px; border-radius:16px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08);
    box-shadow:0 3px 12px rgba(0,0,0,.2); display:flex; align-items:center; gap:14px; backdrop-filter:blur(8px);
  }
  .gallery-card.locked { opacity:.3; }
  .gallery-icon { font-size:40px; flex-shrink:0; filter:drop-shadow(0 2px 6px rgba(0,0,0,.3)); }
  .gallery-info { flex:1; }
  .gallery-name { font-size:15px; font-weight:700; color:#E0E0E0; }
  .gallery-loc { font-size:11px; color:#90A4AE; }
  .gallery-fact { font-size:12px; color:#B0BEC5; margin-top:4px; line-height:1.4; }
  .buddy-wrap { position:absolute; bottom:12px; left:8px; display:flex; align-items:flex-end; gap:6px; z-index:15; pointer-events:none; transition:opacity .3s; }
  .buddy-char { font-size:28px; filter:drop-shadow(0 2px 4px rgba(0,0,0,.3)); animation:buddyBounce 2s ease-in-out infinite; }
  @keyframes buddyBounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-4px)} }
  .buddy-bubble {
    background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.2); border-radius:12px 12px 12px 4px; padding:6px 10px;
    font-size:11px; font-weight:600; color:#E0E0E0; max-width:180px; box-shadow:0 2px 8px rgba(0,0,0,.3);
    animation:bubbleFade .3s ease-out; backdrop-filter:blur(12px);
  }
  @keyframes bubbleFade { from{opacity:0;transform:translateY(5px)} to{opacity:1;transform:translateY(0)} }
  .whatif-panel {
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:16px; max-width:410px; width:100%;
    box-shadow:0 4px 16px rgba(0,0,0,.3); text-align:left; backdrop-filter:blur(8px);
  }
  .whatif-panel h4 { font-size:15px; font-weight:800; color:#E0E0E0; margin-bottom:10px; text-align:center; }
  .whatif-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
  .whatif-row label { font-size:12px; font-weight:700; color:#B0BEC5; width:70px; flex-shrink:0; }
  .whatif-row input[type=range] { flex:1; accent-color:#42A5F5; }
  .whatif-row .val { font-size:12px; font-weight:700; color:#90A4AE; width:40px; text-align:right; }
  .player-banner {
    display:none; padding:6px 12px; border-radius:10px; text-align:center; font-size:13px; font-weight:800;
    flex-shrink:0;
  }
  .player-banner.active { display:block; }
  .player-banner.p1 { background:rgba(33,150,243,.15); color:#64B5F6; border:2px solid rgba(33,150,243,.3); }
  .player-banner.p2 { background:rgba(233,30,99,.15); color:#F48FB1; border:2px solid rgba(233,30,99,.3); }
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div id="app">

  <!-- MENU -->
  <div id="menu" class="screen active">
    <div class="bg-icons" id="bgIcons"></div>
    <div style="font-size:min(18vw,72px);z-index:1">ğŸ—ï¸</div>
    <h1>BUILD LAB</h1>
    <div class="subtitle">Design. Build. Engineer!</div>
    <div class="star-count" id="menuStars" style="display:none">â˜… <span id="menuStarNum">0</span> Stars</div>
    <button class="btn btn-lg btn-orange" onclick="showScreen('worlds')" style="z-index:1;margin-top:8px;">START BUILDING</button>
    <button class="btn btn-md btn-purple" onclick="showScreen('badges')" style="z-index:1">ğŸ† Badges</button>
    <button class="btn btn-md btn-teal" onclick="startDailyChallenge()" style="z-index:1">ğŸ“… Daily Challenge</button>
    <button class="btn btn-md btn-blue" onclick="showScreen('gallery')" style="z-index:1">ğŸŒ Gallery</button>
    <div style="display:flex;gap:8px;z-index:1">
      <button class="btn btn-sm btn-red" onclick="startH2H()" style="flex:1">âš”ï¸ Head-to-Head</button>
      <button class="btn btn-sm btn-green" onclick="startCoOp()" style="flex:1">ğŸ¤ Co-op Build</button>
    </div>
    <div class="age-note">Built for curious minds ages 8+</div>
    <button class="btn btn-sm btn-gray" onclick="sfx.muted=!sfx.muted;this.textContent=sfx.muted?'ğŸ”‡ Sound Off':'ğŸ”Š Sound On'" style="z-index:1;margin-top:4px">ğŸ”Š Sound On</button>
  </div>

  <!-- WORLDS -->
  <div id="worlds" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
      <div style="color:#FFD700;font-size:18px;font-weight:700">â˜… <span id="worldStars">0</span></div>
    </div>
    <h2 style="text-align:center;font-size:28px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(66,165,245,.3)">Choose Your World</h2>
    <div class="worlds-grid" id="worldsGrid"></div>
  </div>

  <!-- LEVELS -->
  <div id="levels" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('worlds')">â† Worlds</button>
      <div style="color:#FFD700;font-size:18px;font-weight:700">â˜… <span id="levelStars">0</span></div>
    </div>
    <h2 id="levelsTitle" style="text-align:center;font-size:26px;font-weight:800;color:#212121"></h2>
    <p id="levelsDesc" style="text-align:center;font-size:14px;color:#757575;margin-bottom:6px"></p>
    <div id="levelList" style="display:flex;flex-direction:column;gap:12px;max-width:500px;margin:0 auto;width:100%"></div>
  </div>

  <!-- INTRO -->
  <div id="intro" class="screen">
    <div class="intro-emoji" id="introEmoji"></div>
    <div class="intro-title" id="introTitle"></div>
    <div class="intro-desc" id="introDesc"></div>
    <div class="tip-card"><div class="label">ğŸ’¡ TIP</div><div class="body" id="introTip"></div></div>
    <div class="fact-card"><div class="label">ğŸ“š DID YOU KNOW?</div><div class="body" id="introFact"></div></div>
    <button class="btn btn-lg btn-green" onclick="startGame()" style="margin-top:8px">LET'S BUILD! ğŸ”¨</button>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="game-topbar">
      <button class="btn btn-sm btn-gray" onclick="exitGame()" style="padding:6px 12px">â† Back</button>
      <div style="text-align:center">
        <div class="title" id="gameTitle"></div>
        <div class="meta" id="gameMeta"></div>
      </div>
      <div style="display:flex;gap:5px">
        <button class="btn btn-sm btn-purple" onclick="toggleHelp()" style="padding:6px 10px">â“</button>
        <button class="btn btn-sm btn-red" id="clearBtn" onclick="clearBeams()" style="padding:6px 12px">Clear</button>
      </div>
    </div>
    <div class="player-banner" id="playerBanner"></div>
    <div class="hint-banner" id="hintBanner">
      <span class="hlabel">ğŸ’¡ HINT: </span>
      <span class="htext" id="hintBannerText"></span>
    </div>
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="gameCanvas"></canvas>
      <div class="help-overlay" id="helpOverlay">
        <div class="help-box">
          <div class="hicon">ğŸ”¨</div>
          <h3>How to Build</h3>
          <p id="helpText">
            <b>1.</b> Tap a dot to select it<br>
            <b>2.</b> Tap a nearby dot to place a beam<br>
            <b>3.</b> Double-tap a beam to remove it<br>
            <b>4.</b> Hit <b>TEST IT!</b> when ready
          </p>
          <button class="btn btn-md btn-orange" onclick="toggleHelp()">Got it!</button>
        </div>
      </div>
      <div class="buddy-wrap" id="buddyWrap">
        <div class="buddy-char">ğŸ‘·</div>
        <div class="buddy-bubble" id="buddyBubble">Let's build something awesome!</div>
      </div>
      <div class="failure-overlay" id="failureOverlay">
        <div class="failure-box">
          <div class="ficon">ğŸ”</div>
          <h3>What Went Wrong</h3>
          <p class="cause" id="failureCause"></p>
          <div class="hint-card">
            <div class="hlabel">ğŸ’¡ HINT</div>
            <div class="hbody" id="failureHint"></div>
          </div>
          <button class="btn btn-md btn-orange" onclick="continueAfterFailure()">Try Again ğŸ”„</button>
        </div>
      </div>
    </div>
    <div class="game-bottombar" id="bottomBar">
      <div style="display:flex;gap:6px" id="matBtns"></div>
      <button class="btn btn-md btn-green" id="testBtn" onclick="startTest()" disabled>TEST IT! ğŸš›</button>
    </div>
    <div id="testingBar" style="display:none;padding:8px 12px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.1);border-radius:14px;text-align:center;flex-shrink:0;backdrop-filter:blur(8px)">
      <div style="font-size:15px;font-weight:700;color:#E0E0E0;margin-bottom:6px" id="testingLabel">ğŸš› Testing your bridge...</div>
      <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
    </div>
  </div>

  <!-- GALLERY -->
  <div id="gallery" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
    </div>
    <h2 style="text-align:center;font-size:26px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(33,150,243,.3)">ğŸŒ Real-World Structures</h2>
    <p style="text-align:center;font-size:14px;color:#90A4AE">Complete levels to unlock real engineering marvels!</p>
    <div class="gallery-grid" id="galleryGrid"></div>
  </div>

  <!-- BADGES -->
  <div id="badges" class="screen">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <button class="btn btn-sm btn-gray" onclick="showScreen('menu')">â† Back</button>
      <div style="font-size:18px;font-weight:700;color:#FF8F00" id="badgeCount">0 / 0</div>
    </div>
    <h2 style="text-align:center;font-size:26px;font-weight:800;color:#fff;text-shadow:0 0 20px rgba(255,215,0,.3)">ğŸ† Builder Badges</h2>
    <p style="text-align:center;font-size:14px;color:#90A4AE">Complete challenges to earn badges!</p>
    <div class="badges-grid" id="badgesGrid"></div>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen">
    <div class="result-emoji" id="resultEmoji"></div>
    <div class="result-title" id="resultTitle"></div>
    <div id="resultStars" class="stars" style="justify-content:center"></div>
    <div class="principle-card" id="principleCard" style="display:none">
      <div class="label" id="principleLabel"></div>
      <div class="body" id="principleBody"></div>
    </div>
    <div class="result-hint" id="resultHint"></div>
    <div id="whatIfPanel" class="whatif-panel" style="display:none">
      <h4>ğŸ”¬ What If...?</h4>
      <div class="whatif-row"><label>Gravity</label><input type="range" id="wifGravity" min="1" max="200" value="100" oninput="document.getElementById('wifGravVal').textContent=this.value+'%'"><span class="val" id="wifGravVal">100%</span></div>
      <div class="whatif-row"><label>Weight</label><input type="range" id="wifWeight" min="25" max="300" value="100" oninput="document.getElementById('wifWeightVal').textContent=this.value+'%'"><span class="val" id="wifWeightVal">100%</span></div>
      <div class="whatif-row"><label>Wind</label><input type="range" id="wifWind" min="0" max="200" value="0" oninput="document.getElementById('wifWindVal').textContent=this.value+'%'"><span class="val" id="wifWindVal">0%</span></div>
      <button class="btn btn-sm btn-teal" onclick="runWhatIf()" style="width:100%;margin-top:4px">Re-Test with These Settings! ğŸ§ª</button>
    </div>
    <div class="result-btns" id="resultBtns"></div>
    <button class="back-link" onclick="showScreen('levels')">Back to Levels</button>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD LAB â€” Complete Game Engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ WORLD DATA â”€â”€
const WORLD_DATA = [
  {
    id:'bridges', name:'Bridges', emoji:'ğŸŒ‰', color:'#2196F3',
    desc:'Build bridges that hold!', testType:'vehicle',
    btnClass:'btn-blue', testLabel:'ğŸš› Testing your bridge...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap a nearby dot to place a beam<br><b>3.</b> Double-tap a beam to remove it<br><b>4.</b> Hit <b>TEST IT!</b> when ready',
    materials:{ wood:{ name:"Wood",color:"#A1887F",stroke:"#6D4C41",maxStress:0.35,width:8,emoji:"ğŸªµ",cost:1 }, steel:{ name:"Steel",color:"#78909C",stroke:"#455A64",maxStress:0.65,width:6,emoji:"ğŸ”©",cost:2 }},
    levels:[
      { id:1,name:"First Bridge",subtitle:"Learn the basics!",description:"Connect the two sides to help the truck cross the river!",tip:"Tap a dot, then tap another nearby dot to place a beam between them.",fact:"The oldest known bridge is over 3,000 years old! Ancient people used fallen trees to cross rivers.",emoji:"ğŸŒ‰",gridW:8,gridH:5,cellSize:65,anchors:[[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[6,2],[6,3],[6,4],[7,2],[7,3],[7,4]],groundTiles:[[0,3],[0,4],[1,3],[1,4],[6,3],[6,4],[7,3],[7,4]],waterTiles:[[2,3],[2,4],[3,3],[3,4],[4,3],[4,4],[5,3],[5,4]],roadY:2,roadStartX:0,roadEndX:7,par:8,vehicleWeight:2.5,vehicleSpeed:1.2,principle:"Beams transfer weight to supports on each side.",principleIcon:"ğŸ“" },
      { id:2,name:"Triangle Power",subtitle:"The strongest shape!",description:"This gap is wider! You'll need triangles to make your bridge strong enough.",tip:"Triangles can't be squished out of shape â€” try adding diagonal beams!",fact:"The Eiffel Tower is made of 18,038 iron pieces connected in triangles. That's what makes it so strong!",emoji:"ğŸ—¼",gridW:9,gridH:6,cellSize:58,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[7,2],[7,3],[7,4],[7,5],[8,2],[8,3],[8,4],[8,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5],[6,3],[6,4],[6,5]],roadY:2,roadStartX:0,roadEndX:8,par:14,vehicleWeight:3.0,vehicleSpeed:1.0,principle:"Triangles are the strongest shape in engineering!",principleIcon:"ğŸ”º" },
      { id:3,name:"The Pillar",subtitle:"Build UP to go ACROSS!",description:"Use the rock in the middle of the river as a support pillar!",tip:"Pillars push weight straight down. Build down to the rock, then bridge across!",fact:"Ancient Romans built aqueducts with tall pillars â€” some still work 2,000 years later!",emoji:"ğŸ›ï¸",gridW:10,gridH:6,cellSize:52,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[8,2],[8,3],[8,4],[8,5],[9,2],[9,3],[9,4],[9,5],[4,4],[4,5],[5,4],[5,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[8,3],[8,4],[8,5],[9,3],[9,4],[9,5],[4,4],[4,5],[5,4],[5,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[6,3],[6,4],[6,5],[7,3],[7,4],[7,5]],roadY:2,roadStartX:0,roadEndX:9,par:18,vehicleWeight:3.5,vehicleSpeed:0.9,principle:"Pillars carry weight straight down â€” the shorter the pillar, the stronger!",principleIcon:"ğŸ—ï¸" },
      { id:4,name:"Heavy Hauler",subtitle:"Can your bridge handle it?",description:"A super heavy truck needs to cross! Steel beams might help.",tip:"Steel is stronger than wood but costs more. Use steel where the load is heaviest!",fact:"The Golden Gate Bridge holds 4,000 vehicles at once! Its cables have 80,000 miles of steel wire.",emoji:"ğŸŒ",gridW:9,gridH:6,cellSize:58,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[7,2],[7,3],[7,4],[7,5],[8,2],[8,3],[8,4],[8,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5],[6,3],[6,4],[6,5]],roadY:2,roadStartX:0,roadEndX:8,par:16,vehicleWeight:5.5,vehicleSpeed:0.7,principle:"Engineers pick the right material for each job!",principleIcon:"ğŸ’ª" },
      { id:5,name:"Master Builder",subtitle:"The ultimate challenge!",description:"A deep canyon with tricky terrain. Use everything you've learned!",tip:"Combine triangles, pillars, and smart material choices!",fact:"The Millau Viaduct in France is taller than the Eiffel Tower! Engineers spent 3 years building it.",emoji:"ğŸ”ï¸",gridW:11,gridH:7,cellSize:48,anchors:[[0,2],[0,3],[0,4],[0,5],[0,6],[1,2],[1,3],[1,4],[1,5],[1,6],[9,3],[9,4],[9,5],[9,6],[10,3],[10,4],[10,5],[10,6],[5,5],[5,6]],groundTiles:[[0,3],[0,4],[0,5],[0,6],[1,3],[1,4],[1,5],[1,6],[9,4],[9,5],[9,6],[10,4],[10,5],[10,6],[5,5],[5,6]],waterTiles:[[2,4],[2,5],[2,6],[3,4],[3,5],[3,6],[4,4],[4,5],[4,6],[6,4],[6,5],[6,6],[7,4],[7,5],[7,6],[8,4],[8,5],[8,6]],roadY:2,roadStartX:0,roadEndX:10,par:24,vehicleWeight:4.5,vehicleSpeed:0.8,principle:"Real engineers combine triangles, pillars, and smart materials!",principleIcon:"ğŸ“" }
    ]
  },
  {
    id:'towers', name:'Towers', emoji:'ğŸ°', color:'#7C4DFF',
    desc:'Stack high & stay stable!', testType:'weight',
    btnClass:'btn-purple', testLabel:'â¬‡ï¸ Dropping the weight...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap another dot to place a beam<br><b>3.</b> Build UP from the ground to the target line<br><b>4.</b> Hit <b>TEST IT!</b> when ready',
    materials:{ wood:{ name:"Wood",color:"#A1887F",stroke:"#6D4C41",maxStress:0.35,width:8,emoji:"ğŸªµ",cost:1 }, steel:{ name:"Steel",color:"#78909C",stroke:"#455A64",maxStress:0.65,width:6,emoji:"ğŸ”©",cost:2 }},
    levels:[
      { id:1,name:"First Tower",subtitle:"Build up!",description:"Stack beams upward to reach the red target line at the top!",tip:"A wide base makes your tower stable â€” like a pyramid!",fact:"The Great Pyramid of Giza was the tallest building for 3,800 years! Its wide base is the key.",emoji:"ğŸ—¼",gridW:5,gridH:7,cellSize:60,anchors:[[0,5],[1,5],[2,5],[3,5],[4,5]],groundTiles:[[0,6],[1,6],[2,6],[3,6],[4,6]],waterTiles:[],targetRow:1,par:10,testWeight:2.0,principle:"A wide base distributes weight â€” that's why pyramids last forever!",principleIcon:"ğŸ“" },
      { id:2,name:"Triangle Tower",subtitle:"Triangles make it strong!",description:"Build higher! You'll need triangles to keep it from wobbling.",tip:"Add diagonal beams between vertical ones to form triangles â€” they resist bending!",fact:"The Eiffel Tower uses triangles everywhere. That's why it can flex in the wind without breaking!",emoji:"ğŸ”º",gridW:5,gridH:8,cellSize:55,anchors:[[0,6],[1,6],[2,6],[3,6],[4,6]],groundTiles:[[0,7],[1,7],[2,7],[3,7],[4,7]],waterTiles:[],targetRow:1,par:14,testWeight:3.0,principle:"Triangles are rigid â€” they can't be squished out of shape like squares!",principleIcon:"ğŸ”º" },
      { id:3,name:"Wind Blower",subtitle:"Can it handle the breeze?",description:"Wind pushes hard from the side! Build a tower that won't topple.",tip:"Cross-bracing (X shapes) helps resist sideways forces. Brace your tower!",fact:"Taipei 101 has a 728-ton pendulum inside that swings to fight wind! It reduces swaying by 40%.",emoji:"ğŸ’¨",gridW:6,gridH:8,cellSize:52,anchors:[[0,6],[1,6],[2,6],[3,6],[4,6],[5,6]],groundTiles:[[0,7],[1,7],[2,7],[3,7],[4,7],[5,7]],waterTiles:[],targetRow:1,par:16,testWeight:2.5,windForce:0.18,principle:"Cross-bracing helps structures resist horizontal forces like wind!",principleIcon:"ğŸ’¨" },
      { id:4,name:"Sky Scraper",subtitle:"Reach for the sky!",description:"Build the tallest, strongest tower. Use everything you know!",tip:"Wide base + triangles + cross-bracing + strong materials = skyscraper!",fact:"The Burj Khalifa is 2,717 feet tall â€” over half a mile! Its Y-shape helps resist wind.",emoji:"ğŸ™ï¸",gridW:7,gridH:9,cellSize:48,anchors:[[0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],groundTiles:[[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8]],waterTiles:[],targetRow:1,par:22,testWeight:4.0,windForce:0.1,principle:"Real skyscrapers combine a strong core, cross-bracing, and wide foundations!",principleIcon:"ğŸ—ï¸" }
    ]
  },
  {
    id:'arches', name:'Arches', emoji:'ğŸ›ï¸', color:'#009688',
    desc:'Span the gap with stone!', testType:'weight',
    btnClass:'btn-teal', testLabel:'â¬‡ï¸ Applying the load...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap another dot to place a beam<br><b>3.</b> Build a structure that spans the gap using angled beams<br><b>4.</b> Hit <b>TEST IT!</b> to drop the weight!',
    materials:{ stone:{ name:"Stone",color:"#8D6E63",stroke:"#5D4037",maxStress:0.40,width:9,emoji:"ğŸª¨",cost:1 }, marble:{ name:"Marble",color:"#B0BEC5",stroke:"#607D8B",maxStress:0.70,width:7,emoji:"ğŸ’",cost:2 }},
    levels:[
      { id:1,name:"Stone Span",subtitle:"Bridge the gap with stone!",description:"Use angled beams from each side to meet in the middle and support the weight above.",tip:"Build angled beams upward from each support to meet at the top â€” like an upside-down V. This pushes weight outward to the strong supports.",fact:"Romans built arches from wedge-shaped stones, each one leaning on the next. Many still stand 2,000 years later!",emoji:"ğŸ›ï¸",gridW:7,gridH:5,cellSize:65,anchors:[[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[5,2],[5,3],[5,4],[6,2],[6,3],[6,4]],groundTiles:[[0,3],[0,4],[1,3],[1,4],[5,3],[5,4],[6,3],[6,4]],waterTiles:[[2,3],[2,4],[3,3],[3,4],[4,3],[4,4]],targetRow:0,par:10,testWeight:3.5,principle:"Angled beams push weight outward to the supports on each side â€” this is the arch principle!",principleIcon:"ğŸ›ï¸" },
      { id:2,name:"Roman Span",subtitle:"Build like the Romans!",description:"A wider gap! Use angled beams from both sides to meet at a strong peak in the middle.",tip:"Where the angled beams meet at the top is the keystone area â€” make sure it has plenty of connections to stay locked together.",fact:"Roman aqueducts used arches to carry water across valleys. The Pont du Gard in France is 160 feet tall!",emoji:"ğŸº",gridW:9,gridH:6,cellSize:58,anchors:[[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[7,2],[7,3],[7,4],[7,5],[8,2],[8,3],[8,4],[8,5]],groundTiles:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],waterTiles:[[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5],[6,3],[6,4],[6,5]],targetRow:0,par:14,testWeight:4.5,principle:"The keystone area at the top locks the two sides together â€” it's the most important part!",principleIcon:"ğŸ”‘" },
      { id:3,name:"Gothic Point",subtitle:"Reach to the heavens!",description:"Build a tall, pointed structure that rises high to support a heavy load from above.",tip:"A tall pointed shape directs weight downward more efficiently. Build steep angles from both sides meeting at a high point!",fact:"Gothic cathedrals like Notre-Dame use pointed arches and flying buttresses to reach incredible heights!",emoji:"â›ª",gridW:9,gridH:7,cellSize:52,anchors:[[0,3],[0,4],[0,5],[0,6],[1,3],[1,4],[1,5],[1,6],[7,3],[7,4],[7,5],[7,6],[8,3],[8,4],[8,5],[8,6]],groundTiles:[[0,4],[0,5],[0,6],[1,4],[1,5],[1,6],[7,4],[7,5],[7,6],[8,4],[8,5],[8,6]],waterTiles:[[2,4],[2,5],[2,6],[3,4],[3,5],[3,6],[4,4],[4,5],[4,6],[5,4],[5,5],[5,6],[6,4],[6,5],[6,6]],targetRow:0,par:16,testWeight:5.0,principle:"Steep, pointed shapes direct forces more vertically, making them even stronger!",principleIcon:"â›ª" },
      { id:4,name:"The Aqueduct",subtitle:"Carry water across!",description:"A long span! Use the middle pillar to build two smaller spans instead of one big one.",tip:"Use the middle pillar as an extra support! Two smaller spans are much stronger than one giant one.",fact:"The Romans built aqueducts spanning hundreds of miles. The longest, the Zaghouan, was 82 miles!",emoji:"ğŸŒŠ",gridW:11,gridH:7,cellSize:48,anchors:[[0,3],[0,4],[0,5],[0,6],[1,3],[1,4],[1,5],[1,6],[9,3],[9,4],[9,5],[9,6],[10,3],[10,4],[10,5],[10,6],[5,5],[5,6]],groundTiles:[[0,4],[0,5],[0,6],[1,4],[1,5],[1,6],[9,4],[9,5],[9,6],[10,4],[10,5],[10,6],[5,5],[5,6]],waterTiles:[[2,4],[2,5],[2,6],[3,4],[3,5],[3,6],[4,4],[4,5],[4,6],[6,4],[6,5],[6,6],[7,4],[7,5],[7,6],[8,4],[8,5],[8,6]],targetRow:0,par:22,testWeight:5.5,principle:"Dividing a long span into smaller sections with pillars multiplies the strength!",principleIcon:"ğŸ—ï¸" }
    ]
  },
  {
    id:'circuits', name:'Circuits', emoji:'âš¡', color:'#E91E63',
    desc:'Wire up & power on!', testType:'circuit',
    btnClass:'btn-pink', testLabel:'âš¡ Sending electricity...',
    helpText:'<b>1.</b> Tap a dot to select it<br><b>2.</b> Tap another dot to place a wire<br><b>3.</b> Connect the ğŸ”‹ battery to all ğŸ’¡ bulbs<br><b>4.</b> Hit <b>TEST IT!</b> to send power!',
    materials:{ copper:{ name:"Copper",color:"#FF9800",stroke:"#E65100",maxStress:1,width:6,emoji:"ğŸ”Œ",cost:1 }, fiber:{ name:"Fiber",color:"#00BCD4",stroke:"#006064",maxStress:1,width:4,emoji:"ğŸ’",cost:2 }},
    levels:[
      { id:1,name:"Light It Up",subtitle:"Complete the circuit!",description:"Connect the battery to the light bulb to turn it on!",tip:"Electricity needs a complete path â€” connect dots from the battery all the way to the bulb.",fact:"Thomas Edison tested over 3,000 designs before finding the right light bulb filament!",emoji:"ğŸ’¡",gridW:6,gridH:3,cellSize:80,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,1]],targets:[[5,1]],blocked:[],par:5,principle:"A circuit needs an unbroken path from power source to device!",principleIcon:"âš¡" },
      { id:2,name:"Two Lights",subtitle:"Power them both!",description:"One battery, two bulbs. Can you wire them both?",tip:"You can branch your wires â€” split the path to reach both bulbs!",fact:"In your house, most outlets run in parallel circuits. That way if one light goes out, the others stay on!",emoji:"ğŸ’¡ğŸ’¡",gridW:7,gridH:5,cellSize:65,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,2]],targets:[[6,0],[6,4]],blocked:[],par:8,principle:"Parallel circuits let multiple devices share one power source!",principleIcon:"ğŸ”€" },
      { id:3,name:"Around the Block",subtitle:"Find a path!",description:"Obstacles block the direct route. Wire around them to reach the bulb!",tip:"You can't go through the red blocks â€” find a path around them!",fact:"Circuit board designers use clever routing to fit thousands of connections on a tiny chip!",emoji:"ğŸ§©",gridW:7,gridH:5,cellSize:65,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,2]],targets:[[6,2]],blocked:[[2,1],[2,2],[2,3],[4,1],[4,2],[4,3]],par:8,principle:"Engineers route circuits around obstacles â€” just like solving a maze!",principleIcon:"ğŸ§©" },
      { id:4,name:"Power Grid",subtitle:"Light up the city!",description:"Multiple batteries, multiple bulbs. Design an efficient power grid!",tip:"Plan your routes carefully â€” try to share wires between different paths.",fact:"The US power grid is the largest machine ever built, with over 450,000 miles of transmission lines!",emoji:"ğŸ™ï¸",gridW:8,gridH:6,cellSize:58,anchors:[],groundTiles:[],waterTiles:[],sources:[[0,1],[0,4]],targets:[[7,0],[7,3],[7,5]],blocked:[[3,0],[3,1],[3,4],[3,5],[5,1],[5,2],[5,3],[5,4]],par:12,principle:"Smart grid design minimizes wires while keeping everything powered!",principleIcon:"ğŸŒ" }
    ]
  }
];

// â”€â”€ PHYSICS CONSTANTS â”€â”€
const GRAVITY = 0.4, DAMPING = 0.98, ITERATIONS = 8, BREAK_MULT = 2.5;

// â”€â”€ STATE â”€â”€
let currentWorld = 0;
let currentLevel = 0;
let earnedStars = {};
let material = '';
let selectedNode = null;
let gameNodes = [];
let gameBeams = [];
let helpVisible = true;
let isTesting = false;
let animId = null;
let vehicle = null;
let canvas, ctx;
let physicsNodes = [], physicsBeams = [];
let failurePhase = null;
let failureFrames = 0;
let failureData = null;
let lastHint = {};
let levelAttempts = {};
let weightObj = null;
let circuitParticles = [];
let circuitReached = new Set();

// â”€â”€ PERSISTENCE â”€â”€
function saveProgress() {
  try { localStorage.setItem('buildlab_stars', JSON.stringify(earnedStars)); } catch(e) {}
  try { localStorage.setItem('buildlab_attempts', JSON.stringify(levelAttempts)); } catch(e) {}
  // Hints are session-only now â€” not persisted to avoid stale cross-world tips
}
function loadProgress() {
  try { earnedStars = JSON.parse(localStorage.getItem('buildlab_stars')) || {}; } catch(e) { earnedStars = {}; }
  try { levelAttempts = JSON.parse(localStorage.getItem('buildlab_attempts')) || {}; } catch(e) { levelAttempts = {}; }
  // Clear stale hints from before world-specific fix (v2)
  lastHint = {};
  try { localStorage.removeItem('buildlab_hints'); } catch(e) {}
}

// â”€â”€ HELPERS â”€â”€
function starKey(wi, li) { return `${wi}_${li}`; }
function getTotalStars() { return Object.values(earnedStars).reduce((a,b)=>a+b,0); }
function getWorldStars(wi) {
  const w = WORLD_DATA[wi]; let t=0;
  for (let i=0;i<w.levels.length;i++) t += earnedStars[starKey(wi,i)]||0;
  return t;
}
function starsHTML(c,sz) { sz=sz||28; let h=''; for(let i=0;i<3;i++) h+=`<span class="star ${i<c?'on':'off'}" style="font-size:${sz}px">â˜…</span>`; return h; }
function getLevel() {
  if (window._isDailyChallenge && window._dailyLevel) return window._dailyLevel;
  return WORLD_DATA[currentWorld].levels[currentLevel];
}
function getWorld() { return WORLD_DATA[currentWorld]; }

// â”€â”€ SCREENS â”€â”€
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if (id==='menu') updateMenuStars();
  if (id==='worlds') renderWorlds();
  if (id==='levels') renderLevels();
  if (id==='badges') renderBadges();
  if (id==='gallery') renderGallery();
}

function updateMenuStars() {
  const total = getTotalStars();
  const el = document.getElementById('menuStars');
  const num = document.getElementById('menuStarNum');
  if (total>0) { el.style.display='block'; num.textContent=total; }
  else el.style.display='none';
}

// â”€â”€ WORLDS â”€â”€
function renderWorlds() {
  document.getElementById('worldStars').textContent = getTotalStars();
  const grid = document.getElementById('worldsGrid');
  grid.innerHTML = '';
  WORLD_DATA.forEach((w,i) => {
    const ws = getWorldStars(i);
    const maxS = w.levels.length * 3;
    const card = document.createElement('button');
    card.className = 'world-card';
    card.style.background = `linear-gradient(135deg,${w.color},${w.color}cc)`;
    card.style.boxShadow = `0 6px 20px ${w.color}44`;
    card.innerHTML = `
      <div class="emoji">${w.emoji}</div>
      <div class="wname">${w.name}</div>
      <div class="wdesc">${w.desc}</div>
      <div class="wstars">â˜… ${ws} / ${maxS}</div>
    `;
    card.onclick = () => { currentWorld=i; showScreen('levels'); };
    grid.appendChild(card);
  });
}

// â”€â”€ LEVELS â”€â”€
function renderLevels() {
  const w = getWorld();
  const ws = getWorldStars(currentWorld);
  document.getElementById('levelStars').textContent = ws;
  document.getElementById('levelsTitle').innerHTML = `${w.emoji} ${w.name}`;
  document.getElementById('levelsDesc').textContent = w.desc;
  const list = document.getElementById('levelList');
  list.innerHTML = '';
  w.levels.forEach((l,i) => {
    const sk = starKey(currentWorld,i);
    const unlocked = i===0 || (earnedStars[starKey(currentWorld,i-1)]||0)>0;
    const btn = document.createElement('button');
    btn.className = 'level-btn' + (unlocked?'':' locked');
    btn.innerHTML = `
      <div class="level-num" style="background:${unlocked?`linear-gradient(135deg,${w.color},${w.color}cc)`:'#BDBDBD'}">
        ${unlocked ? l.id : 'ğŸ”’'}
      </div>
      <div class="level-info">
        <div class="level-name">${l.name}</div>
        <div class="level-sub">${l.subtitle}</div>
      </div>
      <div class="stars">${starsHTML(earnedStars[sk]||0, 20)}</div>
    `;
    if (unlocked) btn.onclick = () => showIntro(i);
    list.appendChild(btn);
  });
}

// â”€â”€ INTRO â”€â”€
function showIntro(idx) {
  currentLevel = idx;
  const l = getLevel();
  document.getElementById('introEmoji').textContent = l.emoji;
  document.getElementById('introTitle').textContent = `Level ${l.id}: ${l.name}`;
  document.getElementById('introDesc').textContent = l.description;
  document.getElementById('introTip').textContent = l.tip;
  document.getElementById('introFact').textContent = l.fact;
  showScreen('intro');
}

// â”€â”€ INIT GAME â”€â”€
function startGame() {
  const w = getWorld();
  const l = getLevel();
  const anchorSet = new Set(l.anchors.map(([x,y])=>`${x},${y}`));
  gameNodes = []; gameBeams = []; selectedNode = null;
  isTesting = false; vehicle = null; weightObj = null;
  failurePhase = null; failureData = null; whatIfOverrides = null;
  circuitParticles = []; circuitReached = new Set();

  // Set default material
  const matKeys = Object.keys(w.materials);
  material = matKeys[0];

  // Create nodes
  if (w.testType === 'circuit') {
    const blockedSet = new Set((l.blocked||[]).map(([x,y])=>`${x},${y}`));
    const srcSet = new Set((l.sources||[]).map(([x,y])=>`${x},${y}`));
    const tgtSet = new Set((l.targets||[]).map(([x,y])=>`${x},${y}`));
    for (let gx=0; gx<l.gridW; gx++) {
      for (let gy=0; gy<l.gridH; gy++) {
        if (blockedSet.has(`${gx},${gy}`)) continue;
        const isSrc = srcSet.has(`${gx},${gy}`);
        const isTgt = tgtSet.has(`${gx},${gy}`);
        gameNodes.push({ x:60+gx*l.cellSize, y:60+gy*l.cellSize, px:60+gx*l.cellSize, py:60+gy*l.cellSize, fixed:true, gx, gy, nodeType: isSrc?'source':isTgt?'target':'normal' });
      }
    }
  } else {
    for (let gx=0; gx<l.gridW; gx++) {
      for (let gy=0; gy<l.gridH; gy++) {
        const isGround = l.groundTiles.some(([tx,ty])=>tx===gx&&ty===gy);
        const isWater = l.waterTiles && l.waterTiles.some(([tx,ty])=>tx===gx&&ty===gy);
        if (isGround || isWater) continue;
        const fixed = anchorSet.has(`${gx},${gy}`);
        gameNodes.push({ x:40+gx*l.cellSize, y:40+gy*l.cellSize, px:40+gx*l.cellSize, py:40+gy*l.cellSize, fixed, gx, gy, nodeType:'normal' });
      }
    }
  }

  showScreen('game');
  initCanvas();
  updateMaterialBtns();
  updateGameUI();

  // Update help text
  document.getElementById('helpText').innerHTML = w.helpText;
  document.getElementById('helpOverlay').style.display = 'flex';
  helpVisible = true;
  document.getElementById('failureOverlay').classList.remove('active');
  document.getElementById('bottomBar').style.display = 'flex';
  document.getElementById('testingBar').style.display = 'none';
  document.getElementById('testingLabel').textContent = w.testLabel;

  // Show hint banner if we have a previous hint
  const hk = starKey(currentWorld, currentLevel);
  const hintBanner = document.getElementById('hintBanner');
  if (lastHint[hk]) {
    document.getElementById('hintBannerText').textContent = lastHint[hk];
    hintBanner.classList.add('active');
  } else {
    hintBanner.classList.remove('active');
  }

  // Update test button text
  const testBtn = document.getElementById('testBtn');
  if (w.testType === 'circuit') testBtn.innerHTML = 'TEST IT! âš¡';
  else if (w.testType === 'weight') testBtn.innerHTML = 'TEST IT! â¬‡ï¸';
  else testBtn.innerHTML = 'TEST IT! ğŸš›';

  buddy.startTips();
  drawGame();
}

function initCanvas() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
}

function resizeCanvas() {
  const l = getLevel();
  const w = getWorld();
  const wrap = document.getElementById('canvasWrap');
  const pad = w.testType==='circuit' ? 120 : 80;
  const cw = l.gridW * l.cellSize + pad;
  const ch = l.gridH * l.cellSize + pad;
  const aspect = cw/ch;
  const maxW = wrap.clientWidth;
  const maxH = wrap.clientHeight || 500;
  let rw, rh;
  if (maxW/maxH > aspect) { rh=maxH; rw=rh*aspect; } else { rw=maxW; rh=rw/aspect; }
  canvas.width = cw; canvas.height = ch;
  canvas.style.width = rw+'px'; canvas.style.height = rh+'px';
}

// â”€â”€ MATERIAL BUTTONS â”€â”€
function updateMaterialBtns() {
  const w = getWorld();
  const container = document.getElementById('matBtns');
  container.innerHTML = '';
  for (const [key, mat] of Object.entries(w.materials)) {
    const btn = document.createElement('button');
    btn.className = 'mat-btn' + (material===key?' active':'');
    btn.innerHTML = `${mat.emoji} ${mat.name}`;
    btn.onclick = () => { material=key; updateMaterialBtns(); };
    container.appendChild(btn);
  }
}

function updateGameUI() {
  const l = getLevel();
  document.getElementById('gameTitle').textContent = l.name;
  const w = getWorld();
  const beamWord = w.testType==='circuit' ? 'Wires' : 'Beams';
  document.getElementById('gameMeta').textContent = `${beamWord}: ${gameBeams.length} | Par: ${l.par}`;
  document.getElementById('testBtn').disabled = gameBeams.length === 0;
}

function toggleHelp() {
  helpVisible = !helpVisible;
  document.getElementById('helpOverlay').style.display = helpVisible ? 'flex' : 'none';
}
function clearBeams() { gameBeams=[]; selectedNode=null; updateGameUI(); drawGame(); }
function exitGame() {
  isTesting=false; failurePhase=null;
  if (animId) cancelAnimationFrame(animId);
  vehicle=null; weightObj=null; buddy.stop();
  window._isDailyChallenge = false; window._dailyLevel = null;
  h2hState = null; coopState = null; hidePlayerBanner();
  showScreen('levels');
}

// â”€â”€ CANVAS INPUT â”€â”€
(function() {
  let lastTap = 0;
  document.addEventListener('DOMContentLoaded', () => {
    const c = document.getElementById('gameCanvas');
    c.addEventListener('pointerdown', (e) => {
      if (isTesting || failurePhase) return;
      e.preventDefault();
      const pt = canvasPoint(e);
      if (!pt) return;
      const now = Date.now();
      if (now - lastTap < 350) { removeBeamAt(pt); lastTap=0; return; }
      lastTap = now;
      let closest=null, closestDist=35;
      for (const n of gameNodes) {
        const d = Math.hypot(n.x-pt.x, n.y-pt.y);
        if (d<closestDist) { closestDist=d; closest=n; }
      }
      if (!closest) { selectedNode=null; drawGame(); return; }
      if (!selectedNode) { selectedNode=closest; }
      else if (closest===selectedNode) { selectedNode=null; }
      else {
        const exists = gameBeams.some(b=>!b.broken&&((b.a===selectedNode&&b.b===closest)||(b.a===closest&&b.b===selectedNode)));
        if (!exists) {
          const gdx=Math.abs(closest.gx-selectedNode.gx), gdy=Math.abs(closest.gy-selectedNode.gy);
          if (gdx<=2 && gdy<=2 && !(gdx===0&&gdy===0)) {
            const dx=closest.x-selectedNode.x, dy=closest.y-selectedNode.y;
            gameBeams.push({ a:selectedNode, b:closest, material, restLength:Math.sqrt(dx*dx+dy*dy), stress:0, broken:false });
            sfx.play('place');
            if (coopState) coopAfterBeamPlaced();
          }
        }
        selectedNode=null;
      }
      updateGameUI(); drawGame();
    });
  });
})();

function canvasPoint(e) {
  if (!canvas) return null;
  const r=canvas.getBoundingClientRect();
  return { x:(e.clientX-r.left)*(canvas.width/r.width), y:(e.clientY-r.top)*(canvas.height/r.height) };
}

function removeBeamAt(pt) {
  let ci=-1, cd=25;
  gameBeams.forEach((b,i) => {
    if (b.broken) return;
    const dx=b.b.x-b.a.x, dy=b.b.y-b.a.y;
    const l2=dx*dx+dy*dy;
    let t=l2===0?0:((pt.x-b.a.x)*dx+(pt.y-b.a.y)*dy)/l2;
    t=Math.max(0,Math.min(1,t));
    const d=Math.hypot(pt.x-(b.a.x+t*dx), pt.y-(b.a.y+t*dy));
    if (d<cd) { cd=d; ci=i; }
  });
  if (ci>=0) { gameBeams.splice(ci,1); sfx.play('remove'); updateGameUI(); drawGame(); }
}

// â”€â”€ DRAWING â”€â”€
function drawGame() {
  if (!ctx) return;
  const w = getWorld();
  if (w.testType==='circuit') drawCircuitWorld();
  else if (w.id==='towers') drawTowerWorld();
  else if (w.id==='arches') drawArchWorld();
  else drawBridgeWorld();
}

function drawBridgeWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Sky
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#87CEEB'); sg.addColorStop(1,'#E0F4FF');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  // Clouds
  drawClouds(W);
  // Water
  drawWater(l);
  // Ground
  drawGround(l);
  // Beams & Nodes
  drawBeamsAndNodes();
  // Vehicle
  if (vehicle && vehicle.active) drawVehicle();
  // Weight for arches
  if (weightObj && weightObj.active) drawWeight();
  // Failure highlights
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawTowerWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Sky gradient
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#5C6BC0'); sg.addColorStop(0.5,'#9FA8DA'); sg.addColorStop(1,'#C5CAE9');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  drawClouds(W);
  // Ground
  drawGround(l);
  // Target line
  if (l.targetRow !== undefined) {
    const ty = 40 + l.targetRow * l.cellSize;
    ctx.setLineDash([8,6]);
    ctx.strokeStyle='#F44336'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(20,ty); ctx.lineTo(W-20,ty); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='#F44336'; ctx.font='bold 13px sans-serif'; ctx.textAlign='right';
    ctx.fillText('TARGET â–¸',W-25,ty-6);
  }
  drawBeamsAndNodes();
  if (weightObj && weightObj.active) drawWeight();
  // Wind indicator
  if (l.windForce && isTesting) {
    ctx.fillStyle='rgba(100,181,246,0.3)';
    ctx.font='bold 24px sans-serif'; ctx.textAlign='center';
    const windX = 30, windY = H/2;
    for (let i=0;i<3;i++) ctx.fillText('â†’',windX,windY-30+i*30);
    ctx.font='bold 11px sans-serif'; ctx.fillText('WIND',windX+5,windY+50);
  }
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawArchWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  // Warm stone sky
  const sg=ctx.createLinearGradient(0,0,0,H);
  sg.addColorStop(0,'#FFE0B2'); sg.addColorStop(1,'#FFF3E0');
  ctx.fillStyle=sg; ctx.fillRect(0,0,W,H);
  drawClouds(W);
  drawWater(l);
  // Stone ground
  for (const [gx,gy] of l.groundTiles) {
    const tx=40+gx*l.cellSize-l.cellSize/2, ty=40+gy*l.cellSize-l.cellSize/2;
    ctx.fillStyle = '#A1887F';
    ctx.fillRect(tx,ty,l.cellSize,l.cellSize);
    ctx.strokeStyle = '#8D6E63'; ctx.lineWidth=1;
    ctx.strokeRect(tx+2,ty+2,l.cellSize-4,l.cellSize-4);
  }
  drawBeamsAndNodes();
  if (weightObj && weightObj.active) drawWeight();
  if (failurePhase==='slowmo') drawFailureHighlights();
}

function drawCircuitWorld() {
  const l = getLevel();
  const W=canvas.width, H=canvas.height;
  const w = getWorld();
  // Dark background
  ctx.fillStyle='#0d1117'; ctx.fillRect(0,0,W,H);
  // Grid lines
  ctx.strokeStyle='rgba(48,54,61,0.6)'; ctx.lineWidth=1;
  for (let x=60;x<W;x+=l.cellSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y=60;y<H;y+=l.cellSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  // Blocked cells
  if (l.blocked) {
    for (const [bx,by] of l.blocked) {
      const cx=60+bx*l.cellSize, cy=60+by*l.cellSize;
      ctx.fillStyle='rgba(244,67,54,0.15)';
      ctx.fillRect(cx-l.cellSize/2+2,cy-l.cellSize/2+2,l.cellSize-4,l.cellSize-4);
      ctx.strokeStyle='rgba(244,67,54,0.4)'; ctx.lineWidth=2;
      ctx.strokeRect(cx-l.cellSize/2+2,cy-l.cellSize/2+2,l.cellSize-4,l.cellSize-4);
      ctx.strokeStyle='#F44336'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(cx-8,cy-8); ctx.lineTo(cx+8,cy+8); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx+8,cy-8); ctx.lineTo(cx-8,cy+8); ctx.stroke();
    }
  }
  // Wires (beams)
  const drawB = isTesting ? physicsBeams : gameBeams;
  for (const beam of drawB) {
    if (beam.broken) continue;
    const mat = w.materials[beam.material];
    const powered = isTesting && circuitReached.has(beam.a) && circuitReached.has(beam.b);
    // Glow
    if (powered) {
      ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
      ctx.strokeStyle = beam.material==='copper' ? 'rgba(255,152,0,0.3)' : 'rgba(0,188,212,0.3)';
      ctx.lineWidth = mat.width+8; ctx.lineCap='round'; ctx.stroke();
    }
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = powered ? (beam.material==='copper'?'#FFB74D':'#4DD0E1') : mat.color;
    ctx.lineWidth = mat.width; ctx.lineCap='round'; ctx.stroke();
  }
  // Particles
  if (isTesting) {
    for (const p of circuitParticles) {
      ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2);
      ctx.fillStyle='#FFEB3B'; ctx.fill();
      ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2);
      ctx.fillStyle='rgba(255,235,59,0.2)'; ctx.fill();
    }
  }
  // Nodes
  const drawN = isTesting ? physicsNodes : gameNodes;
  for (const n of drawN) {
    const powered = isTesting && circuitReached.has(n);
    if (n.nodeType==='source') {
      ctx.beginPath(); ctx.arc(n.x,n.y,16,0,Math.PI*2);
      ctx.fillStyle=powered?'#FFD600':'#FFC107'; ctx.fill();
      ctx.strokeStyle='#FF8F00'; ctx.lineWidth=3; ctx.stroke();
      ctx.fillStyle='#000'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('ğŸ”‹',n.x,n.y);
    } else if (n.nodeType==='target') {
      ctx.beginPath(); ctx.arc(n.x,n.y,16,0,Math.PI*2);
      ctx.fillStyle=powered?'#FFEB3B':'#263238'; ctx.fill();
      ctx.strokeStyle=powered?'#FFD600':'#00BCD4'; ctx.lineWidth=3; ctx.stroke();
      ctx.fillStyle=powered?'#000':'#fff'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(powered?'ğŸ’¡':'ğŸ’¡',n.x,n.y);
      if (powered) {
        ctx.beginPath(); ctx.arc(n.x,n.y,22,0,Math.PI*2);
        ctx.fillStyle='rgba(255,235,59,0.15)'; ctx.fill();
      }
    } else {
      ctx.beginPath(); ctx.arc(n.x,n.y,5,0,Math.PI*2);
      ctx.fillStyle = powered?'#4CAF50':'#455A64'; ctx.fill();
    }
    if (selectedNode===n && !isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,20,0,Math.PI*2);
      ctx.strokeStyle='#FF9800'; ctx.lineWidth=3;
      ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
    }
  }
}

// â”€â”€ SHARED DRAW HELPERS â”€â”€
function drawClouds(W) {
  ctx.fillStyle='rgba(255,255,255,0.5)';
  const t=Date.now()*0.00008;
  for (let i=0;i<5;i++) {
    const cx=((i*180+t*60*(i+1))%(W+120))-60;
    const cy=15+i*22;
    ctx.beginPath(); ctx.arc(cx,cy,22,0,Math.PI*2); ctx.arc(cx+18,cy-7,17,0,Math.PI*2); ctx.arc(cx+36,cy,20,0,Math.PI*2); ctx.fill();
  }
}

function drawWater(l) {
  if (!l.waterTiles) return;
  for (const [gx,gy] of l.waterTiles) {
    const wx=40+gx*l.cellSize-l.cellSize/2, wy=40+gy*l.cellSize-l.cellSize/2;
    const wg=ctx.createLinearGradient(wx,wy,wx,wy+l.cellSize);
    wg.addColorStop(0,'#29B6F6'); wg.addColorStop(1,'#0288D1');
    ctx.fillStyle=wg; ctx.fillRect(wx,wy,l.cellSize,l.cellSize);
    ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1.5;
    const wt=Date.now()*0.003;
    ctx.beginPath();
    for (let px=wx;px<wx+l.cellSize;px+=3) ctx.lineTo(px,wy+8+Math.sin(wt+px*0.08)*3);
    ctx.stroke();
  }
}

function drawGround(l) {
  for (const [gx,gy] of l.groundTiles) {
    const tx=40+gx*l.cellSize-l.cellSize/2, ty=40+gy*l.cellSize-l.cellSize/2;
    ctx.fillStyle='#4CAF50'; ctx.fillRect(tx,ty,l.cellSize,l.cellSize);
    ctx.fillStyle='#66BB6A';
    for (let g=0;g<3;g++) {
      const gxp=tx+8+g*18;
      ctx.beginPath(); ctx.moveTo(gxp,ty); ctx.lineTo(gxp+3,ty-5); ctx.lineTo(gxp+6,ty); ctx.fill();
    }
  }
}

function drawBeamsAndNodes() {
  const w = getWorld();
  const drawB = isTesting ? physicsBeams : gameBeams;
  for (const beam of drawB) {
    if (beam.broken) {
      ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y);
      const mx=(beam.a.x+beam.b.x)/2, my=(beam.a.y+beam.b.y)/2;
      ctx.lineTo(mx+(Math.random()*10-5),my+Math.random()*10);
      ctx.strokeStyle='rgba(200,100,100,0.4)'; ctx.lineWidth=3; ctx.stroke();
      continue;
    }
    const mat = w.materials[beam.material];
    const sc = beam.stress<mat.maxStress*0.5?'#4CAF50':beam.stress<mat.maxStress?'#FFC107':'#F44336';
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = isTesting?'rgba(0,0,0,0.15)':mat.stroke;
    ctx.lineWidth=mat.width+3; ctx.lineCap='round'; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(beam.a.x,beam.a.y); ctx.lineTo(beam.b.x,beam.b.y);
    ctx.strokeStyle = isTesting?sc:mat.color;
    ctx.lineWidth=mat.width; ctx.lineCap='round'; ctx.stroke();
  }
  const drawN = isTesting ? physicsNodes : gameNodes;
  for (const n of drawN) {
    if (n.fixed) {
      ctx.beginPath(); ctx.arc(n.x,n.y,13,0,Math.PI*2);
      ctx.strokeStyle='#FFD54F'; ctx.lineWidth=2; ctx.stroke();
      ctx.beginPath(); ctx.arc(n.x,n.y,9,0,Math.PI*2);
      ctx.fillStyle='#FF6F00'; ctx.fill();
      ctx.beginPath(); ctx.arc(n.x,n.y,4,0,Math.PI*2);
      ctx.fillStyle='#fff'; ctx.fill();
    } else if (!isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,5,0,Math.PI*2);
      ctx.fillStyle='#90A4AE'; ctx.fill();
    }
    if (selectedNode===n && !isTesting) {
      ctx.beginPath(); ctx.arc(n.x,n.y,18,0,Math.PI*2);
      ctx.strokeStyle='#FF9800'; ctx.lineWidth=3;
      ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
    }
  }
}

function drawVehicle() {
  const vx=vehicle.x, vy=vehicle.y-18;
  ctx.fillStyle='rgba(0,0,0,0.1)';
  ctx.beginPath(); ctx.ellipse(vx,vy+28,24,5,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#FF5722'; roundRect(ctx,vx-22,vy-14,44,22,5); ctx.fill();
  ctx.fillStyle='#E64A19'; roundRect(ctx,vx+4,vy-26,18,16,4); ctx.fill();
  ctx.fillStyle='#B3E5FC'; ctx.fillRect(vx+7,vy-23,12,9);
  ctx.fillStyle='#333';
  ctx.beginPath(); ctx.arc(vx-12,vy+8,7,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(vx+12,vy+8,7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#999';
  ctx.beginPath(); ctx.arc(vx-12,vy+8,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(vx+12,vy+8,3,0,Math.PI*2); ctx.fill();
}

function drawWeight() {
  const wx=weightObj.x, wy=weightObj.y;
  // Shadow
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.beginPath(); ctx.ellipse(wx,wy+30,30,6,0,0,Math.PI*2); ctx.fill();
  // Block
  ctx.fillStyle='#5D4037'; roundRect(ctx,wx-25,wy-18,50,36,6); ctx.fill();
  ctx.fillStyle='#4E342E'; roundRect(ctx,wx-22,wy-15,44,30,4); ctx.fill();
  // Label
  ctx.fillStyle='#FFCC80'; ctx.font='bold 12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('HEAVY',wx,wy);
  // Chains
  ctx.strokeStyle='#9E9E9E'; ctx.lineWidth=2;
  ctx.setLineDash([3,3]);
  ctx.beginPath(); ctx.moveTo(wx-10,wy-18); ctx.lineTo(wx-10,wy-45); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(wx+10,wy-18); ctx.lineTo(wx+10,wy-45); ctx.stroke();
  ctx.setLineDash([]);
}

function drawFailureHighlights() {
  if (!failureData) return;
  const pulse = 0.5 + 0.5*Math.sin(Date.now()*0.008);
  for (const bp of failureData.breakPoints) {
    ctx.beginPath(); ctx.arc(bp.x,bp.y,25+pulse*10,0,Math.PI*2);
    ctx.fillStyle=`rgba(244,67,54,${0.15+pulse*0.15})`;
    ctx.fill();
    ctx.strokeStyle=`rgba(244,67,54,${0.5+pulse*0.3})`;
    ctx.lineWidth=3; ctx.stroke();
  }
  // Slow-mo label
  ctx.fillStyle='rgba(0,0,0,0.6)';
  roundRect(ctx,canvas.width/2-70,10,140,30,8); ctx.fill();
  ctx.fillStyle='#F44336'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('ğŸ” ANALYZING...',canvas.width/2,25);
}

function roundRect(ctx,x,y,w,h,r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// â”€â”€ PHYSICS â”€â”€
function stepPhysics(speedMult) {
  const l = getLevel();
  const w = getWorld();
  const sm = speedMult || 1;
  for (const n of physicsNodes) {
    if (n.fixed) continue;
    const vx=(n.x-n.px)*DAMPING*sm;
    const vy=(n.y-n.py)*DAMPING*sm;
    n.px=n.x; n.py=n.y;
    const gMult = whatIfOverrides ? whatIfOverrides.gravMult : 1;
    n.x+=vx; n.y+=vy+GRAVITY*sm*gMult;
    // Wind
    const windBase = l.windForce || 0;
    const windExtra = whatIfOverrides ? whatIfOverrides.windPct * 0.3 : 0;
    if ((windBase || windExtra) && isTesting) n.x += (windBase + windExtra)*sm;
  }
  // Vehicle force
  if (vehicle && vehicle.active && vehicle.moving) {
    const roadNodes=physicsNodes.filter(n=>n.gy===l.roadY).sort((a,b)=>a.gx-b.gx);
    if (roadNodes.length>=2) {
      for (let i=0;i<roadNodes.length-1;i++) {
        const a=roadNodes[i], b=roadNodes[i+1];
        if (vehicle.x>=a.x && vehicle.x<=b.x) {
          const t=(vehicle.x-a.x)/(b.x-a.x||1);
          const wMult = whatIfOverrides ? whatIfOverrides.weightMult : 1;
          const force=l.vehicleWeight*wMult*GRAVITY*3*sm;
          if (!a.fixed) a.y+=force*(1-t)*0.5;
          if (!b.fixed) b.y+=force*t*0.5;
          vehicle.y=a.y+(b.y-a.y)*t;
          break;
        }
      }
    }
  }
  // Weight force
  if (weightObj && weightObj.active && weightObj.landed) {
    const topNodes = physicsNodes.filter(n=>!n.fixed).sort((a,b)=>a.y-b.y);
    const targetNodes = topNodes.slice(0, Math.max(2, Math.floor(topNodes.length*0.2)));
    for (const n of targetNodes) {
      const wMult2 = whatIfOverrides ? whatIfOverrides.weightMult : 1;
      n.y += (l.testWeight||3)*wMult2*GRAVITY*0.5*sm / targetNodes.length;
    }
    // Update weight position to sit on top
    if (targetNodes.length>0) {
      const avgX = targetNodes.reduce((s,n)=>s+n.x,0)/targetNodes.length;
      const minY = Math.min(...targetNodes.map(n=>n.y));
      weightObj.x = avgX;
      weightObj.y = minY - 20;
    }
  }
  // Constraints
  for (let iter=0;iter<ITERATIONS;iter++) {
    for (const b of physicsBeams) {
      if (b.broken) continue;
      const dx=b.b.x-b.a.x, dy=b.b.y-b.a.y;
      const dist=Math.sqrt(dx*dx+dy*dy)||0.001;
      const diff=(b.restLength-dist)/dist;
      const ox=dx*diff*0.5, oy=dy*diff*0.5;
      if (!b.a.fixed) { b.a.x-=ox; b.a.y-=oy; }
      if (!b.b.fixed) { b.b.x+=ox; b.b.y+=oy; }
      b.stress = Math.abs(dist-b.restLength)/b.restLength;
    }
  }
  // Break
  for (const b of physicsBeams) {
    if (b.broken) continue;
    const w2 = getWorld();
    const mat = w2.materials[b.material];
    if (b.stress > mat.maxStress*BREAK_MULT) { b.broken=true; sfx.play('breakBeam'); buddy.say('break'); }
  }
  return physicsNodes.some(n=>!n.fixed&&n.y>800);
}

// â”€â”€ FAILURE ANALYSIS â”€â”€
function analyzeFailure() {
  const broken = physicsBeams.filter(b=>b.broken);
  const allBeams = physicsBeams.length;
  const l = getLevel();
  const w = getWorld();

  const breakPoints = broken.map(b => ({x:(b.a.x+b.b.x)/2, y:(b.a.y+b.b.y)/2}));

  // Where did most beams break?
  let avgX=canvas.width/2;
  if (breakPoints.length>0) avgX = breakPoints.reduce((s,p)=>s+p.x,0)/breakPoints.length;
  const midX = canvas.width/2;
  const area = avgX<midX*0.7?'left side':avgX>midX*1.3?'right side':'center';

  // Check for triangles
  let hasTriangles = false;
  for (let i=0;i<gameBeams.length&&!hasTriangles;i++) {
    for (let j=i+1;j<gameBeams.length&&!hasTriangles;j++) {
      const shared = [gameBeams[i].a,gameBeams[i].b].filter(n=>[gameBeams[j].a,gameBeams[j].b].includes(n));
      if (shared.length===1) {
        const otherI = gameBeams[i].a===shared[0]?gameBeams[i].b:gameBeams[i].a;
        const otherJ = gameBeams[j].a===shared[0]?gameBeams[j].b:gameBeams[j].a;
        if (gameBeams.some(b=>!b.broken&&((b.a===otherI&&b.b===otherJ)||(b.a===otherJ&&b.b===otherI)))) hasTriangles=true;
      }
    }
  }

  const matKeys = Object.keys(w.materials);
  const allFirstMat = broken.length>0 && broken.every(b=>b.material===matKeys[0]);
  const fewBeams = allBeams < l.par*0.6;

  let cause, hint;
  if (w.testType==='circuit') {
    cause = "Not all bulbs are connected to a battery!";
    hint = "Make sure every bulb has a wire path leading back to a battery.";
  } else if (w.id==='arches') {
    // Arch-specific hints â€” about angled beams, spans, and supports
    if (fewBeams) {
      cause = "Not enough beams to span the gap!";
      hint = "Build angled beams from each support upward to meet in the middle. You need enough beams to make a solid path across!";
    } else if (allFirstMat && matKeys.length>1 && currentLevel>=2) {
      cause = `${w.materials[matKeys[0]].name} wasn't strong enough for this heavy load!`;
      hint = `Try using ${w.materials[matKeys[1]].name} in the ${area} â€” especially where the beams meet at the top, where the weight pushes hardest.`;
    } else if (broken.length > allBeams*0.5) {
      cause = "The structure collapsed â€” the weight wasn't being directed to the supports!";
      hint = "Use angled beams from both sides that meet at the top. Each side should lean into the other so the weight pushes outward to the solid supports.";
    } else {
      cause = `The ${area} of your structure couldn't handle the stress!`;
      hint = `Strengthen the ${area}. Add more connecting beams so the weight has multiple paths to reach the supports on each side.`;
    }
  } else if (w.id==='towers') {
    // Tower-specific hints
    if (fewBeams) {
      cause = "Not enough beams to reach the target height!";
      hint = "Build upward from the ground! Connect dots vertically and add cross-bracing (X shapes) to keep it stable.";
    } else if (!hasTriangles && allBeams >= 4) {
      cause = "Your tower is wobbling â€” it needs cross-bracing!";
      hint = "Add diagonal beams between the vertical ones to make X shapes. This stops the tower from swaying side to side!";
    } else if (allFirstMat && matKeys.length>1 && currentLevel>=2) {
      cause = `${w.materials[matKeys[0]].name} wasn't strong enough at the base!`;
      hint = `Use ${w.materials[matKeys[1]].name} for the lower beams â€” the base carries the most weight.`;
    } else {
      cause = `The ${area} of your tower gave way!`;
      hint = `Make the base wider and add cross-bracing (X shapes) to the ${area}. A wider base means a stronger tower!`;
    }
  } else {
    // Bridge-specific hints (default)
    if (fewBeams) {
      cause = "Not enough beams to support the load!";
      hint = "Add more beams â€” try connecting every nearby pair of dots for extra strength.";
    } else if (!hasTriangles && allBeams >= 4) {
      cause = "Your bridge has rectangular shapes that bend easily under stress!";
      hint = "Add diagonal beams to form triangles â€” triangles are the strongest shape in bridge building!";
    } else if (allFirstMat && matKeys.length>1 && currentLevel>=2) {
      cause = `${w.materials[matKeys[0]].name} wasn't strong enough for this heavy load!`;
      hint = `Try using ${w.materials[matKeys[1]].name} beams in the ${area} where stress is highest.`;
    } else if (broken.length > allBeams*0.5) {
      cause = "Too many beams failed at once â€” the bridge needs better support!";
      hint = `Strengthen the ${area} with more triangles and connect beams to the supports on each side.`;
    } else {
      cause = `The ${area} couldn't handle the stress and collapsed!`;
      hint = `Add more support to the ${area}. Try diagonal beams or stronger materials there.`;
    }
  }

  return { cause, hint, breakPoints };
}

function startFailureAnalysis() {
  failurePhase = 'slowmo';
  failureFrames = 0;
  failureData = analyzeFailure();

  // Store hint for retry
  const hk = starKey(currentWorld, currentLevel);
  lastHint[hk] = failureData.hint;

  // Track attempts
  const ak = starKey(currentWorld, currentLevel);
  levelAttempts[ak] = (levelAttempts[ak]||0) + 1;
  saveProgress();
}

function continueAfterFailure() {
  failurePhase = null;
  if (animId) cancelAnimationFrame(animId);
  document.getElementById('failureOverlay').classList.remove('active');
  isTesting = false;
  vehicle = null;
  weightObj = null;
  showResult(false, 0);
}

// â”€â”€ TESTS â”€â”€
function startTest() {
  if (gameBeams.length===0) return;
  const w = getWorld();
  buddy.say('testing'); buddy.stop();
  if (w.testType==='circuit') { startCircuitTest(); return; }

  const l = getLevel();
  isTesting = true;
  helpVisible = false;
  failurePhase = null; failureData = null;
  document.getElementById('helpOverlay').style.display='none';
  document.getElementById('hintBanner').classList.remove('active');
  document.getElementById('bottomBar').style.display='none';
  document.getElementById('testingBar').style.display='block';
  document.getElementById('clearBtn').disabled=true;
  document.getElementById('failureOverlay').classList.remove('active');

  // Deep clone
  physicsNodes = gameNodes.map(n=>({...n}));
  physicsBeams = gameBeams.map(b=>({
    ...b,
    a: physicsNodes.find(n=>n.gx===b.a.gx&&n.gy===b.a.gy),
    b: physicsNodes.find(n=>n.gx===b.b.gx&&n.gy===b.b.gy)
  }));

  if (w.testType==='vehicle') startVehicleTest();
  else startWeightTest();
}

function startVehicleTest() {
  const l = getLevel();
  const startX = 40+l.roadStartX*l.cellSize;
  const endX = 40+l.roadEndX*l.cellSize;
  vehicle = { x:startX-30, y:40+l.roadY*l.cellSize, active:true, moving:false, progress:0 };
  let settleFrames = 0;

  function loop() {
    if (failurePhase==='slowmo') {
      failureFrames++;
      stepPhysics(0.25);
      drawGame();
      if (failureFrames>100) {
        failurePhase='analysis';
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
        return;
      }
      animId=requestAnimationFrame(loop); return;
    }

    settleFrames++;
    if (settleFrames>45) vehicle.moving=true;
    const fell = stepPhysics(1);

    if (vehicle.moving) {
      vehicle.x += l.vehicleSpeed*1.3;
      vehicle.progress = (vehicle.x-40-l.roadStartX*l.cellSize)/(40+l.roadEndX*l.cellSize-40-l.roadStartX*l.cellSize);
      document.getElementById('progressFill').style.width = Math.max(0,Math.min(100,vehicle.progress*100))+'%';
      if (vehicle.x >= endX+25) {
        isTesting=false; vehicle.active=false;
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
        return;
      }
    }

    if (fell || physicsBeams.filter(b=>!b.broken).length===0 || (vehicle.moving&&vehicle.y>600)) {
      if (!failurePhase) { startFailureAnalysis(); }
    }

    drawGame();
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

function startWeightTest() {
  const l = getLevel();
  // Find center top of structure
  const nonFixed = physicsNodes.filter(n=>!n.fixed);
  let centerX = canvas.width/2;
  if (nonFixed.length>0) centerX = nonFixed.reduce((s,n)=>s+n.x,0)/nonFixed.length;
  weightObj = { x:centerX, y:-20, active:true, landed:false, holdFrames:0 };
  let settleFrames = 0;

  function loop() {
    if (failurePhase==='slowmo') {
      failureFrames++;
      stepPhysics(0.25);
      drawGame();
      if (failureFrames>100) {
        failurePhase='analysis';
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
        return;
      }
      animId=requestAnimationFrame(loop); return;
    }

    settleFrames++;
    const fell = stepPhysics(1);

    // Lower the weight
    if (settleFrames>30 && !weightObj.landed) {
      weightObj.y += 2;
      const topNodes = physicsNodes.filter(n=>!n.fixed).sort((a,b)=>a.y-b.y);
      if (topNodes.length>0 && weightObj.y >= topNodes[0].y - 30) {
        weightObj.landed = true;
      }
    }

    if (weightObj.landed) {
      weightObj.holdFrames++;
      const progress = weightObj.holdFrames/150;
      document.getElementById('progressFill').style.width = Math.min(100,progress*100)+'%';

      if (weightObj.holdFrames >= 150) {
        isTesting=false; weightObj.active=false;
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
        return;
      }
    }

    if (fell || physicsBeams.filter(b=>!b.broken).length===0) {
      if (!failurePhase) { startFailureAnalysis(); }
    }

    drawGame();
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

function startCircuitTest() {
  const l = getLevel();
  isTesting = true;
  helpVisible = false;
  document.getElementById('helpOverlay').style.display='none';
  document.getElementById('hintBanner').classList.remove('active');
  document.getElementById('bottomBar').style.display='none';
  document.getElementById('testingBar').style.display='block';
  document.getElementById('clearBtn').disabled=true;
  document.getElementById('failureOverlay').classList.remove('active');

  physicsNodes = gameNodes.map(n=>({...n}));
  physicsBeams = gameBeams.map(b=>({
    ...b,
    a: physicsNodes.find(n=>n.gx===b.a.gx&&n.gy===b.a.gy),
    b: physicsNodes.find(n=>n.gx===b.b.gx&&n.gy===b.b.gy)
  }));

  // BFS from sources
  circuitReached = new Set();
  circuitParticles = [];
  const sources = physicsNodes.filter(n=>n.nodeType==='source');
  const targets = physicsNodes.filter(n=>n.nodeType==='target');
  const queue = [...sources];
  queue.forEach(n=>circuitReached.add(n));

  while (queue.length>0) {
    const cur = queue.shift();
    for (const wire of physicsBeams) {
      const other = wire.a===cur?wire.b:wire.b===cur?wire.a:null;
      if (other && !circuitReached.has(other)) {
        circuitReached.add(other);
        queue.push(other);
      }
    }
  }

  const allPowered = targets.every(t=>circuitReached.has(t));

  // Create particles along powered wires
  for (const wire of physicsBeams) {
    if (circuitReached.has(wire.a) && circuitReached.has(wire.b)) {
      for (let i=0;i<3;i++) {
        circuitParticles.push({
          wire, t:Math.random(), speed:0.01+Math.random()*0.01,
          x:wire.a.x, y:wire.a.y
        });
      }
    }
  }

  let frames = 0;
  function loop() {
    frames++;
    // Animate particles
    for (const p of circuitParticles) {
      p.t += p.speed;
      if (p.t>1) p.t-=1;
      p.x = p.wire.a.x + (p.wire.b.x-p.wire.a.x)*p.t;
      p.y = p.wire.a.y + (p.wire.b.y-p.wire.a.y)*p.t;
    }
    document.getElementById('progressFill').style.width = Math.min(100,frames/120*100)+'%';

    drawGame();

    if (frames >= 120) {
      isTesting=false;
      if (allPowered) {
        const stars = gameBeams.length<=l.par?3:gameBeams.length<=l.par+4?2:1;
        const sk = starKey(currentWorld,currentLevel);
        earnedStars[sk] = Math.max(earnedStars[sk]||0, stars);
        saveProgress();
        showResult(true, stars);
      } else {
        // Failure for circuits
        const unpowered = targets.filter(t=>!circuitReached.has(t));
        failureData = {
          cause: `${unpowered.length} bulb${unpowered.length>1?'s are':' is'} not connected to a battery!`,
          hint: 'Make sure every bulb has a wire path leading back to a battery. Check for gaps!',
          breakPoints: unpowered.map(n=>({x:n.x,y:n.y}))
        };
        const hk = starKey(currentWorld,currentLevel);
        lastHint[hk] = failureData.hint;
        levelAttempts[hk] = (levelAttempts[hk]||0)+1;
        saveProgress();
        document.getElementById('failureCause').textContent = failureData.cause;
        document.getElementById('failureHint').textContent = failureData.hint;
        document.getElementById('failureOverlay').classList.add('active');
      }
      return;
    }
    animId=requestAnimationFrame(loop);
  }
  animId=requestAnimationFrame(loop);
}

// â”€â”€ RESULT â”€â”€
function showResult(success, stars) {
  if (animId) cancelAnimationFrame(animId);

  // Handle H2H mode
  if (h2hState) {
    if (h2hState.phase === 'p1build' || h2hState.phase === 'p1test') {
      h2hState.p1result = { success, stars, beams: gameBeams.length };
      h2hState.p1beams = gameBeams.map(b => ({ aGx:b.a.gx, aGy:b.a.gy, bGx:b.b.gx, bGy:b.b.gy, material:b.material }));
      h2hState.phase = 'p2build';
      // Show pass-device screen
      showH2HPassDevice();
      return;
    }
    if (h2hState.phase === 'p2build' || h2hState.phase === 'p2test') {
      h2hState.p2result = { success, stars, beams: gameBeams.length };
      h2hState.phase = 'results';
      showH2HResults();
      return;
    }
  }

  // Handle Co-op mode
  if (coopState) {
    coopState = null;
    hidePlayerBanner();
  }

  const l = getLevel();
  const w = getWorld();
  const el = document.getElementById('result');
  el.className = 'screen active '+(success?'success':'fail');

  const successEmojis = { bridges:'ğŸ‰', towers:'ğŸ†', arches:'ğŸ›ï¸', circuits:'ğŸ’¡' };
  const failEmojis = { bridges:'ğŸ’¥', towers:'ğŸ’¨', arches:'ğŸª¨', circuits:'ğŸ”Œ' };
  const successTitles = { bridges:'BRIDGE HELD!', towers:'TOWER STOOD!', arches:'ARCH HELD!', circuits:'CIRCUIT WORKS!' };
  const failTitles = { bridges:'BRIDGE COLLAPSED!', towers:'TOWER FELL!', arches:'ARCH CRUMBLED!', circuits:'NO POWER!' };

  sfx.play(success ? 'success' : 'fail');
  document.getElementById('resultEmoji').textContent = success?successEmojis[w.id]:'ğŸ’¥';
  const title = document.getElementById('resultTitle');
  title.textContent = success?(successTitles[w.id]||'SUCCESS!'):(failTitles[w.id]||'FAILED!');
  title.className = 'result-title '+(success?'win':'lose');

  document.getElementById('resultStars').innerHTML = success?starsHTML(stars,40):'';

  const pc = document.getElementById('principleCard');
  if (success) {
    pc.style.display='block';
    document.getElementById('principleLabel').textContent = (l.principleIcon||'ğŸ“š')+' ENGINEERING PRINCIPLE';
    document.getElementById('principleBody').textContent = l.principle;
  } else pc.style.display='none';

  // Show real-world gallery card on success
  const galleryItem = success ? GALLERY.find(g => g.world === currentWorld && g.level === currentLevel) : null;
  const resultHintEl = document.getElementById('resultHint');
  if (galleryItem && success) {
    resultHintEl.innerHTML = `ğŸŒ <b>Real World:</b> ${galleryItem.emoji} <b>${galleryItem.name}</b> (${galleryItem.loc}) â€” ${galleryItem.fact}`;
    resultHintEl.style.color = '#64B5F6';
  } else {
    resultHintEl.style.color = '#90A4AE';
  }

  const hk = starKey(currentWorld,currentLevel);
  const attempts = levelAttempts[hk]||0;
  if (!success) {
    document.getElementById('resultHint').textContent =
      lastHint[hk] ? `ğŸ’¡ Remember: ${lastHint[hk]}` : "Don't worry â€” even real engineers test many designs! Try again.";
    document.getElementById('resultHint').style.color = '#90A4AE';
  }

  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const retry = document.createElement('button');
  retry.className = 'btn btn-md '+(success?'btn-blue':'btn-orange');
  retry.textContent = success?'Try Again':'Try Again ğŸ”„';
  retry.onclick = () => startGame();
  btns.appendChild(retry);

  // What-If panel
  const wifPanel = document.getElementById('whatIfPanel');
  if (success && w.testType !== 'circuit') {
    wifPanel.style.display = 'block';
    document.getElementById('wifGravity').value = 100;
    document.getElementById('wifWeight').value = 100;
    document.getElementById('wifWind').value = 0;
    document.getElementById('wifGravVal').textContent = '100%';
    document.getElementById('wifWeightVal').textContent = '100%';
    document.getElementById('wifWindVal').textContent = '0%';
  } else {
    wifPanel.style.display = 'none';
  }

  if (success && currentLevel < w.levels.length-1) {
    const next = document.createElement('button');
    next.className = 'btn btn-md btn-green';
    next.textContent = 'Next Level â†’';
    next.onclick = () => { currentLevel++; showIntro(currentLevel); };
    btns.appendChild(next);
  }
  if (success) {
    const shareBtn = document.createElement('button');
    shareBtn.className = 'btn btn-md btn-pink';
    shareBtn.textContent = 'ğŸ“¸ Share Design';
    shareBtn.onclick = () => shareDesign();
    btns.appendChild(shareBtn);
  }

  if (success && currentLevel === w.levels.length-1) {
    const done = document.createElement('button');
    done.className = 'btn btn-md btn-purple';
    done.textContent = 'More Worlds! ğŸŒ';
    done.onclick = () => showScreen('worlds');
    btns.appendChild(done);
  }

  if (success) {
    confetti.launch(stars);
    setTimeout(() => confetti.launch(stars), 400);
    if (stars === 3) setTimeout(() => confetti.launch(3), 800);
    const newBadge = checkBadges();
    if (newBadge) {
      sfx.play('badge');
      setTimeout(() => {
        const hint = document.getElementById('resultHint');
        hint.innerHTML = `ğŸ† <b>NEW BADGE: ${newBadge.emoji} ${newBadge.name}!</b> â€” ${newBadge.desc}<br>` + hint.innerHTML;
        hint.style.color = '#FF8F00';
      }, 600);
    }
  }

  showScreen('result');
}

// â”€â”€ CO-OP BUILD MODE â”€â”€
let coopState = null; // { turn:1|2, beamsP1:0, beamsP2:0 }

function startCoOp() {
  // Pick a random level
  const worldIdx = Math.floor(Math.random() * 3);
  const levelIdx = Math.floor(Math.random() * Math.min(3, WORLD_DATA[worldIdx].levels.length));
  currentWorld = worldIdx;
  currentLevel = levelIdx;
  coopState = { turn: 1, beamsP1: 0, beamsP2: 0 };
  window._isDailyChallenge = false; window._dailyLevel = null;
  h2hState = null;
  showPlayerBanner('ğŸ‘· Player 1 â€” Place a beam!', 'p1');
  startGame();
}

function coopAfterBeamPlaced() {
  if (!coopState) return;
  if (coopState.turn === 1) {
    coopState.beamsP1++;
    coopState.turn = 2;
    showPlayerBanner(`ğŸ€ Player 2 â€” Your turn! (P1: ${coopState.beamsP1} | P2: ${coopState.beamsP2})`, 'p2');
  } else {
    coopState.beamsP2++;
    coopState.turn = 1;
    showPlayerBanner(`ğŸ‘· Player 1 â€” Your turn! (P1: ${coopState.beamsP1} | P2: ${coopState.beamsP2})`, 'p1');
  }
}

// â”€â”€ HEAD-TO-HEAD MODE â”€â”€
let h2hState = null; // { phase:'p1build'|'p1test'|'p2build'|'p2test'|'results', p1beams:[], p1result:null, p2result:null }

function startH2H() {
  // Pick a random bridge level for fairness
  const worldIdx = 0; // bridges
  const levelIdx = Math.floor(Math.random() * Math.min(3, WORLD_DATA[worldIdx].levels.length));
  currentWorld = worldIdx;
  currentLevel = levelIdx;
  h2hState = { phase: 'p1build', p1beams: [], p1result: null, p2result: null, worldIdx, levelIdx };
  window._isDailyChallenge = false; window._dailyLevel = null;
  showPlayerBanner('ğŸ‘· Player 1 â€” Build!', 'p1');
  startGame();
}

function showPlayerBanner(text, pClass) {
  const banner = document.getElementById('playerBanner');
  banner.textContent = text;
  banner.className = 'player-banner active ' + pClass;
}

function hidePlayerBanner() {
  document.getElementById('playerBanner').className = 'player-banner';
}

function showH2HPassDevice() {
  const el = document.getElementById('result');
  el.className = 'screen active success';
  document.getElementById('resultEmoji').textContent = 'ğŸ”„';
  const title = document.getElementById('resultTitle');
  title.textContent = 'PASS THE DEVICE!';
  title.className = 'result-title win';
  title.style.color = '#E91E63';
  document.getElementById('resultStars').innerHTML = '';
  document.getElementById('principleCard').style.display = 'none';
  document.getElementById('whatIfPanel').style.display = 'none';
  const p1 = h2hState.p1result;
  document.getElementById('resultHint').innerHTML = `Player 1: ${p1.success ? 'âœ… Success' : 'âŒ Failed'} (${p1.beams} beams)<br>Now hand the device to <b>Player 2</b>!`;
  document.getElementById('resultHint').style.color = '#B0BEC5';
  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const goBtn = document.createElement('button');
  goBtn.className = 'btn btn-lg btn-pink';
  goBtn.textContent = "Player 2's Turn! ğŸ®";
  goBtn.onclick = () => {
    showPlayerBanner('ğŸ€ Player 2 â€” Build!', 'p2');
    currentWorld = h2hState.worldIdx;
    currentLevel = h2hState.levelIdx;
    startGame();
  };
  btns.appendChild(goBtn);
  showScreen('result');
}

function showH2HResults() {
  hidePlayerBanner();
  const p1 = h2hState.p1result, p2 = h2hState.p2result;
  let winner;
  if (p1.success && !p2.success) winner = 1;
  else if (!p1.success && p2.success) winner = 2;
  else if (p1.success && p2.success) winner = p1.beams <= p2.beams ? 1 : 2;
  else winner = 0; // tie (both failed)

  const el = document.getElementById('result');
  el.className = 'screen active success';
  document.getElementById('resultEmoji').textContent = winner === 0 ? 'ğŸ¤' : 'ğŸ†';
  const title = document.getElementById('resultTitle');
  title.textContent = winner === 0 ? "IT'S A TIE!" : `PLAYER ${winner} WINS!`;
  title.className = 'result-title win';
  document.getElementById('resultStars').innerHTML = '';
  document.getElementById('principleCard').style.display = 'none';
  document.getElementById('whatIfPanel').style.display = 'none';
  document.getElementById('resultHint').innerHTML =
    `ğŸ‘· P1: ${p1.success?'âœ…':'âŒ'} ${p1.beams} beams | ğŸ€ P2: ${p2.success?'âœ…':'âŒ'} ${p2.beams} beams`;
  document.getElementById('resultHint').style.color = '#B0BEC5';

  if (winner > 0) { confetti.launch(3); setTimeout(() => confetti.launch(3), 400); sfx.play('success'); }
  else sfx.play('fail');

  const btns = document.getElementById('resultBtns');
  btns.innerHTML = '';
  const again = document.createElement('button');
  again.className = 'btn btn-md btn-red';
  again.textContent = 'âš”ï¸ Rematch!';
  again.onclick = () => startH2H();
  btns.appendChild(again);
  const menu = document.createElement('button');
  menu.className = 'btn btn-md btn-gray';
  menu.textContent = 'Menu';
  menu.onclick = () => { h2hState = null; showScreen('menu'); };
  btns.appendChild(menu);
  showScreen('result');
  h2hState = null;
}

// â”€â”€ SHARE DESIGN â”€â”€
function shareDesign() {
  if (!canvas) return;
  // Draw a title on a temporary canvas
  const share = document.createElement('canvas');
  share.width = canvas.width;
  share.height = canvas.height + 60;
  const sctx = share.getContext('2d');
  // Header
  sctx.fillStyle = '#1a237e';
  sctx.fillRect(0, 0, share.width, 60);
  sctx.fillStyle = '#fff';
  sctx.font = 'bold 22px sans-serif';
  sctx.textAlign = 'center';
  sctx.textBaseline = 'middle';
  const l = getLevel();
  sctx.fillText(`ğŸ—ï¸ Build Lab â€” ${l.name}`, share.width / 2, 30);
  // Game canvas
  sctx.drawImage(canvas, 0, 60);
  // Convert and share/download
  share.toBlob(blob => {
    if (!blob) return;
    const file = new File([blob], 'my-build.png', { type: 'image/png' });
    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
      navigator.share({ title: 'My Build Lab Design', text: `Check out my ${l.name} design!`, files: [file] }).catch(() => {});
    } else {
      // Fallback: download
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'my-build.png';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  }, 'image/png');
}

// â”€â”€ WHAT-IF MODE â”€â”€
let whatIfOverrides = null;

function runWhatIf() {
  const gravMult = parseInt(document.getElementById('wifGravity').value) / 100;
  const weightMult = parseInt(document.getElementById('wifWeight').value) / 100;
  const windPct = parseInt(document.getElementById('wifWind').value) / 100;
  whatIfOverrides = { gravMult, weightMult, windPct };
  // Restart the game with same beams but modified physics
  showScreen('game');
  initCanvas();
  updateMaterialBtns();
  updateGameUI();
  document.getElementById('helpOverlay').style.display = 'none';
  helpVisible = false;
  // Immediately start test with overrides
  startTest();
}

// â”€â”€ REAL-WORLD GALLERY â”€â”€
const GALLERY = [
  { world:0, level:0, emoji:'ğŸŒ‰', name:'Ponte Vecchio', loc:'Florence, Italy', fact:'Built in 1345, this medieval bridge has shops built right on top of it! It survived World War II.' },
  { world:0, level:1, emoji:'ğŸ—¼', name:'Eiffel Tower', loc:'Paris, France', fact:'Made of 18,038 iron pieces joined by 2.5 million rivets, all connected in triangles for strength.' },
  { world:0, level:2, emoji:'ğŸ›ï¸', name:'Pont du Gard', loc:'France', fact:'A Roman aqueduct bridge with 3 tiers of arches, built 2,000 years ago without mortar!' },
  { world:0, level:3, emoji:'ğŸŒ', name:'Golden Gate Bridge', loc:'San Francisco, USA', fact:'Its cables contain 80,000 miles of steel wire â€” enough to wrap around Earth 3 times!' },
  { world:0, level:4, emoji:'ğŸ”ï¸', name:'Millau Viaduct', loc:'France', fact:'The tallest bridge in the world at 1,125 feet â€” taller than the Eiffel Tower!' },
  { world:1, level:0, emoji:'ğŸ”º', name:'Great Pyramid of Giza', loc:'Egypt', fact:'Was the tallest structure for 3,800 years. Its wide base is the key to its stability.' },
  { world:1, level:1, emoji:'ğŸ—¼', name:'Tokyo Skytree', loc:'Japan', fact:'At 2,080 feet, it uses a central core and triangular cross-bracing to resist earthquakes.' },
  { world:1, level:2, emoji:'ğŸ’¨', name:'Taipei 101', loc:'Taiwan', fact:'Has a 728-ton pendulum that swings to counteract wind! Reduces swaying by 40%.' },
  { world:1, level:3, emoji:'ğŸ™ï¸', name:'Burj Khalifa', loc:'Dubai, UAE', fact:'At 2,717 feet, its Y-shaped floor plan helps resist wind forces from all directions.' },
  { world:2, level:0, emoji:'ğŸ›ï¸', name:'The Colosseum', loc:'Rome, Italy', fact:'Built with 80 arched entrances, it could seat 50,000 spectators nearly 2,000 years ago.' },
  { world:2, level:1, emoji:'ğŸº', name:'Aqueduct of Segovia', loc:'Spain', fact:'163 arches made of granite blocks with no mortar â€” gravity and precise cutting hold it together!' },
  { world:2, level:2, emoji:'â›ª', name:'Notre-Dame Cathedral', loc:'Paris, France', fact:'Its pointed Gothic arches allowed builders to reach unprecedented heights in the 12th century.' },
  { world:2, level:3, emoji:'ğŸŒŠ', name:'Roman Aqueducts', loc:'Roman Empire', fact:'Stretched over 250 miles total, carrying 1 billion liters of water daily to Rome!' },
  { world:3, level:0, emoji:'ğŸ’¡', name:"Edison's Lab", loc:'New Jersey, USA', fact:'Thomas Edison tested over 3,000 designs before perfecting the incandescent light bulb.' },
  { world:3, level:1, emoji:'ğŸ”Œ', name:'Home Wiring', loc:'Everywhere', fact:'Your home uses parallel circuits so each device gets full voltage independently.' },
  { world:3, level:2, emoji:'ğŸ§©', name:'Circuit Boards', loc:'Inside Electronics', fact:'Modern CPUs have billions of transistors routed around obstacles on chips smaller than a fingernail.' },
  { world:3, level:3, emoji:'ğŸŒ', name:'US Power Grid', loc:'USA', fact:'The largest machine ever built: 450,000 miles of transmission lines powering 330 million people.' },
];

function renderGallery() {
  const grid = document.getElementById('galleryGrid');
  grid.innerHTML = '';
  for (const g of GALLERY) {
    const sk = starKey(g.world, g.level);
    const unlocked = (earnedStars[sk] || 0) > 0;
    const card = document.createElement('div');
    card.className = 'gallery-card' + (unlocked ? '' : ' locked');
    card.innerHTML = `
      <div class="gallery-icon">${unlocked ? g.emoji : 'ğŸ”’'}</div>
      <div class="gallery-info">
        <div class="gallery-name">${unlocked ? g.name : '???'}</div>
        <div class="gallery-loc">${unlocked ? g.loc : 'Complete the level to unlock'}</div>
        ${unlocked ? `<div class="gallery-fact">${g.fact}</div>` : ''}
      </div>
    `;
    grid.appendChild(card);
  }
}

// â”€â”€ DAILY CHALLENGE â”€â”€
function seededRandom(seed) {
  let s = seed;
  return function() { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; };
}

function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth()+1) * 100 + d.getDate();
}

function startDailyChallenge() {
  const seed = getDailySeed();
  const rng = seededRandom(seed);
  const worldIdx = Math.floor(rng() * 3); // bridges, towers, arches (not circuits for daily)
  const w = WORLD_DATA[worldIdx];

  // Pick a random existing level as template and modify it
  const templateIdx = Math.floor(rng() * w.levels.length);
  const template = w.levels[templateIdx];

  // Create modified daily level
  const dailyLevel = JSON.parse(JSON.stringify(template));
  dailyLevel.name = "Daily Challenge";
  dailyLevel.subtitle = new Date().toLocaleDateString('en-US', {month:'short', day:'numeric'});
  dailyLevel.emoji = "ğŸ“…";
  dailyLevel.description = `Today's challenge: a ${w.name.toLowerCase()} puzzle! Can you beat it?`;
  dailyLevel.tip = template.tip;
  dailyLevel.fact = template.fact;

  // Modify difficulty slightly using seed
  if (dailyLevel.vehicleWeight) dailyLevel.vehicleWeight = +(dailyLevel.vehicleWeight * (0.8 + rng() * 0.6)).toFixed(1);
  if (dailyLevel.testWeight) dailyLevel.testWeight = +(dailyLevel.testWeight * (0.8 + rng() * 0.6)).toFixed(1);
  dailyLevel.par = Math.max(5, dailyLevel.par + Math.floor(rng() * 5 - 2));

  // Set as current level
  currentWorld = worldIdx;
  // Temporarily inject daily level
  const origLevels = w.levels;
  w.levels = [dailyLevel];
  currentLevel = 0;
  showIntro(0);
  // Restore after intro is shown
  setTimeout(() => { w.levels = origLevels; }, 100);
  // Override startGame to use daily level
  window._dailyLevel = dailyLevel;
  window._dailyWorld = worldIdx;
  window._isDailyChallenge = true;
}

// â”€â”€ CONSTRUCTION BUDDY â”€â”€
const buddy = {
  timer: null,
  messages: {
    start: ["Let's build something awesome!", "Ready to engineer?", "I believe in you!", "Time to construct!"],
    fewBeams: ["Good start! Keep connecting dots!", "Nice! Try adding more beams.", "You're getting the hang of it!"],
    triangles: ["Try adding diagonal beams for triangles!", "Triangles are super strong!", "A diagonal here would help!"],
    arches: ["Build angled beams from each side to meet in the middle!", "The weight should push outward to the strong supports!", "Connect both sides at the top â€” that's where it all locks together!"],
    towers: ["Build wide at the bottom for stability!", "Add X-bracing to stop it swaying!", "A wider base makes a stronger tower!"],
    manyBeams: ["Looking solid! Ready to test?", "Great structure! Let's see if it holds!", "That's some fine engineering!"],
    testing: ["Here we go... ğŸ¤", "Fingers crossed!", "Let's see how it holds!"],
    break: ["Oops! That beam snapped!", "Don't worry, we can fix this!", "Try reinforcing that spot!"],
    circuit: ["Connect the battery to all bulbs!", "Electricity needs a path!", "Wire it up! âš¡"]
  },
  say(category) {
    const msgs = this.messages[category];
    if (!msgs) return;
    const msg = msgs[Math.floor(Math.random() * msgs.length)];
    const bubble = document.getElementById('buddyBubble');
    if (bubble) { bubble.textContent = msg; bubble.style.animation = 'none'; bubble.offsetHeight; bubble.style.animation = 'bubbleFade .3s ease-out'; }
  },
  autoTip() {
    if (isTesting) return;
    const w = getWorld();
    const beamCount = gameBeams.length;
    if (beamCount === 0) this.say('start');
    else if (w.testType === 'circuit') this.say('circuit');
    else if (beamCount < 3) this.say('fewBeams');
    else if (w.id === 'arches' && beamCount < 6) this.say('arches');
    else if (w.id === 'towers' && beamCount < 6) this.say('towers');
    else if (beamCount < 6) this.say('triangles');
    else this.say('manyBeams');
  },
  startTips() {
    this.say('start');
    if (this.timer) clearInterval(this.timer);
    this.timer = setInterval(() => this.autoTip(), 12000);
  },
  stop() { if (this.timer) { clearInterval(this.timer); this.timer = null; } }
};

// â”€â”€ BUILDER BADGES â”€â”€
const BADGES = [
  { id:'first_build', emoji:'ğŸ”¨', name:'First Build', desc:'Complete your first level', check:()=>getTotalStars()>=1 },
  { id:'bridge_master', emoji:'ğŸŒ‰', name:'Bridge Master', desc:'Earn all bridge stars', check:()=>getWorldStars(0)>=15 },
  { id:'tower_master', emoji:'ğŸ°', name:'Tower King', desc:'Earn all tower stars', check:()=>getWorldStars(1)>=12 },
  { id:'arch_master', emoji:'ğŸ›ï¸', name:'Arch Expert', desc:'Earn all arch stars', check:()=>getWorldStars(2)>=12 },
  { id:'circuit_master', emoji:'âš¡', name:'Circuit Whiz', desc:'Earn all circuit stars', check:()=>getWorldStars(3)>=12 },
  { id:'star_collector', emoji:'â­', name:'Star Collector', desc:'Earn 20 total stars', check:()=>getTotalStars()>=20 },
  { id:'perfectionist', emoji:'ğŸ’', name:'Perfectionist', desc:'Get 3 stars on 5 levels', check:()=>Object.values(earnedStars).filter(s=>s===3).length>=5 },
  { id:'engineer', emoji:'ğŸ“', name:'Engineer', desc:'Complete all 4 worlds', check:()=>WORLD_DATA.every((_,i)=>getWorldStars(i)>0 && WORLD_DATA[i].levels.every((_,j)=>(earnedStars[starKey(i,j)]||0)>0)) },
  { id:'persistent', emoji:'ğŸ’ª', name:'Never Give Up', desc:'Retry a level 5+ times', check:()=>Object.values(levelAttempts).some(a=>a>=5) },
  { id:'speedster', emoji:'ğŸš€', name:'Speedster', desc:'Beat a level under par', check:()=>{ for(let wi=0;wi<WORLD_DATA.length;wi++) for(let li=0;li<WORLD_DATA[wi].levels.length;li++) if((earnedStars[starKey(wi,li)]||0)===3) return true; return false; }},
  { id:'all_stars', emoji:'ğŸŒŸ', name:'Superstar', desc:'Earn every single star', check:()=>getTotalStars()>=51 },
  { id:'explorer', emoji:'ğŸ—ºï¸', name:'Explorer', desc:'Try all 4 worlds', check:()=>WORLD_DATA.every((_,i)=>getWorldStars(i)>0) },
];
let earnedBadges = {};

function loadBadges() {
  try { earnedBadges = JSON.parse(localStorage.getItem('buildlab_badges')) || {}; } catch(e) { earnedBadges = {}; }
}
function saveBadges() {
  try { localStorage.setItem('buildlab_badges', JSON.stringify(earnedBadges)); } catch(e) {}
}

function checkBadges() {
  let newBadge = null;
  for (const b of BADGES) {
    if (!earnedBadges[b.id] && b.check()) {
      earnedBadges[b.id] = Date.now();
      newBadge = b;
    }
  }
  saveBadges();
  return newBadge;
}

function renderBadges() {
  const grid = document.getElementById('badgesGrid');
  grid.innerHTML = '';
  const earned = BADGES.filter(b => earnedBadges[b.id]).length;
  document.getElementById('badgeCount').textContent = `${earned} / ${BADGES.length}`;
  for (const b of BADGES) {
    const card = document.createElement('div');
    const isEarned = !!earnedBadges[b.id];
    card.className = 'badge-card ' + (isEarned ? 'earned' : 'locked');
    card.innerHTML = `
      <div class="badge-emoji">${isEarned ? b.emoji : 'ğŸ”’'}</div>
      <div class="badge-name">${b.name}</div>
      <div class="badge-desc">${b.desc}</div>
    `;
    grid.appendChild(card);
  }
}

// â”€â”€ SOUND ENGINE (Web Audio API) â”€â”€
const sfx = {
  ctx: null, unlocked: false, muted: false,
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (this.ctx.state === 'suspended') this.ctx.resume();
    this.unlocked = true;
  },
  unlock() {
    if (this.unlocked) return;
    this.init();
  },
  play(type) {
    if (this.muted || !this.ctx) return;
    try { this[type](); } catch(e) {}
  },
  place() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(440, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(880, this.ctx.currentTime + 0.08);
    g.gain.setValueAtTime(0.15, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
    o.start(); o.stop(this.ctx.currentTime + 0.15);
  },
  remove() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sine'; o.frequency.setValueAtTime(600, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.1);
    g.gain.setValueAtTime(0.12, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);
    o.start(); o.stop(this.ctx.currentTime + 0.12);
  },
  breakBeam() {
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
    const s = this.ctx.createBufferSource(), g = this.ctx.createGain();
    s.buffer = buf; s.connect(g); g.connect(this.ctx.destination);
    g.gain.setValueAtTime(0.2, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    s.start();
  },
  success() {
    const notes = [523, 659, 784, 1047];
    notes.forEach((freq, i) => {
      const o = this.ctx.createOscillator(), g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.type = 'sine'; o.frequency.value = freq;
      const t = this.ctx.currentTime + i * 0.15;
      g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.15, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
      o.start(t); o.stop(t + 0.4);
    });
  },
  fail() {
    const o = this.ctx.createOscillator(), g = this.ctx.createGain();
    o.connect(g); g.connect(this.ctx.destination);
    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.5);
    g.gain.setValueAtTime(0.12, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    o.start(); o.stop(this.ctx.currentTime + 0.5);
  },
  badge() {
    const notes = [784, 988, 1175, 1319, 1568];
    notes.forEach((freq, i) => {
      const o = this.ctx.createOscillator(), g = this.ctx.createGain();
      o.connect(g); g.connect(this.ctx.destination);
      o.type = 'triangle'; o.frequency.value = freq;
      const t = this.ctx.currentTime + i * 0.1;
      g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.12, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      o.start(t); o.stop(t + 0.3);
    });
  }
};

// â”€â”€ CONFETTI CELEBRATION â”€â”€
const confetti = {
  canvas: null, ctx: null, particles: [], animId: null,
  colors: ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#FF922B','#CC5DE8','#20C997','#FF6B9D'],
  init() {
    this.canvas = document.getElementById('confettiCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  },
  resize() {
    if (!this.canvas) return;
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  },
  launch(intensity) {
    const count = intensity === 3 ? 150 : intensity === 2 ? 100 : 60;
    for (let i = 0; i < count; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: -20 - Math.random() * 200,
        vx: (Math.random() - 0.5) * 8,
        vy: Math.random() * 3 + 2,
        size: Math.random() * 8 + 4,
        color: this.colors[Math.floor(Math.random() * this.colors.length)],
        rotation: Math.random() * 360,
        rotSpeed: (Math.random() - 0.5) * 12,
        shape: Math.random() > 0.5 ? 'rect' : 'circle',
        life: 1,
        decay: 0.003 + Math.random() * 0.004,
        wobble: Math.random() * 10,
        wobbleSpeed: 0.03 + Math.random() * 0.05
      });
    }
    if (!this.animId) this.animate();
  },
  animate() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += p.vx + Math.sin(p.wobble) * 0.5;
      p.y += p.vy;
      p.vy += 0.04;
      p.vx *= 0.99;
      p.rotation += p.rotSpeed;
      p.wobble += p.wobbleSpeed;
      p.life -= p.decay;
      if (p.life <= 0 || p.y > this.canvas.height + 20) {
        this.particles.splice(i, 1); continue;
      }
      this.ctx.save();
      this.ctx.translate(p.x, p.y);
      this.ctx.rotate(p.rotation * Math.PI / 180);
      this.ctx.globalAlpha = p.life;
      this.ctx.fillStyle = p.color;
      if (p.shape === 'rect') {
        this.ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
      } else {
        this.ctx.beginPath();
        this.ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
        this.ctx.fill();
      }
      this.ctx.restore();
    }
    if (this.particles.length > 0) {
      this.animId = requestAnimationFrame(() => this.animate());
    } else {
      this.animId = null;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
  }
};

// â”€â”€ BG ICONS â”€â”€
function setupMenuBG() {
  const icons=['âš™ï¸','ğŸ”§','ğŸ”©','ğŸ—ï¸','ğŸ“','ğŸ”¨','ğŸªµ','âš¡','ğŸ›ï¸','ğŸŒ‰'];
  const container = document.getElementById('bgIcons');
  for (let i=0;i<18;i++) {
    const span = document.createElement('span');
    span.className='bg-icon';
    span.style.left=(i*37%100)+'%';
    span.style.top=(i*53%100)+'%';
    span.style.fontSize=[22,30,18,26,24,20][i%6]+'px';
    span.style.transform=`rotate(${i*30}deg)`;
    span.textContent=icons[i%icons.length];
    container.appendChild(span);
  }
}

// â”€â”€ RESIZE â”€â”€
window.addEventListener('resize', () => {
  if (document.getElementById('game').classList.contains('active') && canvas) {
    resizeCanvas(); drawGame();
  }
});

// â”€â”€ INIT â”€â”€
document.addEventListener('DOMContentLoaded', () => {
  loadProgress();
  loadBadges();
  setupMenuBG();
  updateMenuStars();
  confetti.init();
  document.addEventListener('touchstart', e => { sfx.unlock(); if(e.touches.length>1)e.preventDefault(); },{passive:false});
  document.addEventListener('mousedown', () => sfx.unlock(), {once:true});
  let lastTouch=0;
  document.addEventListener('touchend', e => { const now=Date.now(); if(now-lastTouch<=300)e.preventDefault(); lastTouch=now; },false);
});
</script>
</body>
</html>
